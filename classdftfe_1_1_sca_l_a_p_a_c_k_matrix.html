<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DFT-FE: dftfe::ScaLAPACKMatrix&lt; NumberType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DFT-FE<span id="projectnumber">&#160;1.1.0-pre</span>
   </div>
   <div id="projectbrief">Density Functional Theory With Finite-Elements</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedftfe.html">dftfe</a></li><li class="navelem"><a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">dftfe::ScaLAPACKMatrix&lt; NumberType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Scalapack wrapper adapted from dealii library and extended implementation to complex datatype.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="scalapack_wrapper_8h_source.html">scalapackWrapper.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4caf4c02adc2c4ab39026a39be6b243a" id="r_a4caf4c02adc2c4ab39026a39be6b243a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a> = unsigned int</td></tr>
<tr class="separator:a4caf4c02adc2c4ab39026a39be6b243a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a877a61dc7a8aa371b9f7655268cf4cd3" id="r_a877a61dc7a8aa371b9f7655268cf4cd3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a877a61dc7a8aa371b9f7655268cf4cd3">ScaLAPACKMatrix</a> (const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a> <a class="el" href="#a45b24efb278a43b1696a379a2b332bab">n_rows</a>, const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a> <a class="el" href="#a63d09a13a0bedeeb0e38abc743584d2c">n_columns</a>, const std::shared_ptr&lt; const <a class="el" href="classdftfe_1_1_process_grid.html">dftfe::ProcessGrid</a> &gt; &amp;process_grid, const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a> <a class="el" href="#ac49f03ec236b08f7670343cf072f912d">row_block_size</a>=32, const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a> <a class="el" href="#ab16408c54c2082adfbca8c7a143f5028">column_block_size</a>=32, const <a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9ac">dftfe::LAPACKSupport::Property</a> <a class="el" href="#a0c818961322247597311ada36af4c6b7">property</a>=<a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9aca63df404db8dd3aaa130bb72937c25107">dftfe::LAPACKSupport::Property::general</a>)</td></tr>
<tr class="separator:a877a61dc7a8aa371b9f7655268cf4cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6025e77abed29ca914a56ae5e11f00e0" id="r_a6025e77abed29ca914a56ae5e11f00e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6025e77abed29ca914a56ae5e11f00e0">ScaLAPACKMatrix</a> (const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a> size, const std::shared_ptr&lt; const <a class="el" href="classdftfe_1_1_process_grid.html">dftfe::ProcessGrid</a> &gt; &amp;process_grid, const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a> block_size=32, const <a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9ac">dftfe::LAPACKSupport::Property</a> <a class="el" href="#a0c818961322247597311ada36af4c6b7">property</a>=<a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9acacb022b5e749ecd8aded585fa69365425">dftfe::LAPACKSupport::Property::hermitian</a>)</td></tr>
<tr class="separator:a6025e77abed29ca914a56ae5e11f00e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a08450144cb221e7ebaa5cf0ba1a02b" id="r_a1a08450144cb221e7ebaa5cf0ba1a02b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a08450144cb221e7ebaa5cf0ba1a02b">reinit</a> (const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a> <a class="el" href="#a45b24efb278a43b1696a379a2b332bab">n_rows</a>, const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a> <a class="el" href="#a63d09a13a0bedeeb0e38abc743584d2c">n_columns</a>, const std::shared_ptr&lt; const <a class="el" href="classdftfe_1_1_process_grid.html">dftfe::ProcessGrid</a> &gt; &amp;process_grid, const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a> <a class="el" href="#ac49f03ec236b08f7670343cf072f912d">row_block_size</a>=32, const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a> <a class="el" href="#ab16408c54c2082adfbca8c7a143f5028">column_block_size</a>=32, const <a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9ac">dftfe::LAPACKSupport::Property</a> <a class="el" href="#a0c818961322247597311ada36af4c6b7">property</a>=<a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9aca63df404db8dd3aaa130bb72937c25107">dftfe::LAPACKSupport::Property::general</a>)</td></tr>
<tr class="separator:a1a08450144cb221e7ebaa5cf0ba1a02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1144c2f751a2e2d6245dcde85d9958d1" id="r_a1144c2f751a2e2d6245dcde85d9958d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1144c2f751a2e2d6245dcde85d9958d1">reinit</a> (const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a> size, const std::shared_ptr&lt; const <a class="el" href="classdftfe_1_1_process_grid.html">dftfe::ProcessGrid</a> &gt; &amp;process_grid, const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a> block_size=32, const <a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9ac">dftfe::LAPACKSupport::Property</a> <a class="el" href="#a0c818961322247597311ada36af4c6b7">property</a>=<a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9acacb022b5e749ecd8aded585fa69365425">dftfe::LAPACKSupport::Property::hermitian</a>)</td></tr>
<tr class="separator:a1144c2f751a2e2d6245dcde85d9958d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7da23c4243e9ace668a66239039bed" id="r_a5c7da23c4243e9ace668a66239039bed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c7da23c4243e9ace668a66239039bed">set_property</a> (const <a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9ac">dftfe::LAPACKSupport::Property</a> <a class="el" href="#a0c818961322247597311ada36af4c6b7">property</a>)</td></tr>
<tr class="separator:a5c7da23c4243e9ace668a66239039bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6213590579de7473604c7b7fc7fb1dcc" id="r_a6213590579de7473604c7b7fc7fb1dcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9ac">dftfe::LAPACKSupport::Property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6213590579de7473604c7b7fc7fb1dcc">get_property</a> () const</td></tr>
<tr class="separator:a6213590579de7473604c7b7fc7fb1dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6277fcc0a927bb6bed309eaaef18cc" id="r_a1b6277fcc0a927bb6bed309eaaef18cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#a50176057fe971f54ce6bddd1f09e6d06">dftfe::LAPACKSupport::State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b6277fcc0a927bb6bed309eaaef18cc">get_state</a> () const</td></tr>
<tr class="separator:a1b6277fcc0a927bb6bed309eaaef18cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b846add6ba88a8e9b1f1af7750e3a9c" id="r_a2b846add6ba88a8e9b1f1af7750e3a9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b846add6ba88a8e9b1f1af7750e3a9c">copy_to</a> (<a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;dest) const</td></tr>
<tr class="separator:a2b846add6ba88a8e9b1f1af7750e3a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ffac5802f6c8aa4e4f8faf739b85f7" id="r_a46ffac5802f6c8aa4e4f8faf739b85f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46ffac5802f6c8aa4e4f8faf739b85f7">conjugate</a> ()</td></tr>
<tr class="separator:a46ffac5802f6c8aa4e4f8faf739b85f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d20c5ad908996be22d9bc6a452e5d4" id="r_a42d20c5ad908996be22d9bc6a452e5d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42d20c5ad908996be22d9bc6a452e5d4">add</a> (const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const NumberType a=0., const NumberType b=1., const bool transpose_B=false)</td></tr>
<tr class="separator:a42d20c5ad908996be22d9bc6a452e5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2ff1dc6410222c2fca0d20fe8ef983" id="r_a6b2ff1dc6410222c2fca0d20fe8ef983"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b2ff1dc6410222c2fca0d20fe8ef983">zadd</a> (const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const NumberType a=0., const NumberType b=1., const bool conjugate_transpose_B=false)</td></tr>
<tr class="separator:a6b2ff1dc6410222c2fca0d20fe8ef983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab607c0944accd8bc9b549e43c57f695a" id="r_ab607c0944accd8bc9b549e43c57f695a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab607c0944accd8bc9b549e43c57f695a">copy_transposed</a> (const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B)</td></tr>
<tr class="separator:ab607c0944accd8bc9b549e43c57f695a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dd4e08159c26e5fae262f9ca8dc183" id="r_a04dd4e08159c26e5fae262f9ca8dc183"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04dd4e08159c26e5fae262f9ca8dc183">copy_conjugate_transposed</a> (const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B)</td></tr>
<tr class="separator:a04dd4e08159c26e5fae262f9ca8dc183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245caef57db69751ecdebc120ff4b456" id="r_a245caef57db69751ecdebc120ff4b456"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a245caef57db69751ecdebc120ff4b456">mult</a> (const NumberType b, const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const NumberType c, <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;C, const bool transpose_A=false, const bool transpose_B=false) const</td></tr>
<tr class="separator:a245caef57db69751ecdebc120ff4b456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d041424c4ab89f58557c1c92e167c0" id="r_a88d041424c4ab89f58557c1c92e167c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88d041424c4ab89f58557c1c92e167c0">zmult</a> (const NumberType b, const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const NumberType c, <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;C, const bool conjugate_transpose_A=false, const bool conjugate_transpose_B=false) const</td></tr>
<tr class="separator:a88d041424c4ab89f58557c1c92e167c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cde52bed9faa050dce904c96eebce0" id="r_ab9cde52bed9faa050dce904c96eebce0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9cde52bed9faa050dce904c96eebce0">mmult</a> (<a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;C, const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const bool adding=false) const</td></tr>
<tr class="separator:ab9cde52bed9faa050dce904c96eebce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9a582f73de96239b2ffa4ead2934cd" id="r_a6f9a582f73de96239b2ffa4ead2934cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f9a582f73de96239b2ffa4ead2934cd">Tmmult</a> (<a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;C, const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const bool adding=false) const</td></tr>
<tr class="separator:a6f9a582f73de96239b2ffa4ead2934cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707a28c545abba69394929b0ff934fdd" id="r_a707a28c545abba69394929b0ff934fdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a707a28c545abba69394929b0ff934fdd">mTmult</a> (<a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;C, const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const bool adding=false) const</td></tr>
<tr class="separator:a707a28c545abba69394929b0ff934fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac663b0fe6a673b3fef08226fdd24d9b" id="r_aac663b0fe6a673b3fef08226fdd24d9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac663b0fe6a673b3fef08226fdd24d9b">TmTmult</a> (<a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;C, const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const bool adding=false) const</td></tr>
<tr class="separator:aac663b0fe6a673b3fef08226fdd24d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dce63d8bd4dccf4624d41350398107e" id="r_a2dce63d8bd4dccf4624d41350398107e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dce63d8bd4dccf4624d41350398107e">zmmult</a> (<a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;C, const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const bool adding=false) const</td></tr>
<tr class="separator:a2dce63d8bd4dccf4624d41350398107e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63411b9232cad71c462c8fa9e057bd56" id="r_a63411b9232cad71c462c8fa9e057bd56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63411b9232cad71c462c8fa9e057bd56">zCmmult</a> (<a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;C, const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const bool adding=false) const</td></tr>
<tr class="separator:a63411b9232cad71c462c8fa9e057bd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f3f5e5913f82d3e303e55728179b90" id="r_a86f3f5e5913f82d3e303e55728179b90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86f3f5e5913f82d3e303e55728179b90">zmCmult</a> (<a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;C, const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const bool adding=false) const</td></tr>
<tr class="separator:a86f3f5e5913f82d3e303e55728179b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3aeb1d84498e30020980c34e3612ea9" id="r_ae3aeb1d84498e30020980c34e3612ea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3aeb1d84498e30020980c34e3612ea9">zCmCmult</a> (<a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;C, const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const bool adding=false) const</td></tr>
<tr class="separator:ae3aeb1d84498e30020980c34e3612ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e8a50bfee69f4bf767b41fd4621f52" id="r_a58e8a50bfee69f4bf767b41fd4621f52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58e8a50bfee69f4bf767b41fd4621f52">m</a> () const</td></tr>
<tr class="separator:a58e8a50bfee69f4bf767b41fd4621f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c494fd3964387d621a45c8f25e664d" id="r_a41c494fd3964387d621a45c8f25e664d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41c494fd3964387d621a45c8f25e664d">n</a> () const</td></tr>
<tr class="separator:a41c494fd3964387d621a45c8f25e664d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34aea7e92abd44b2a47142f2fa546671" id="r_a34aea7e92abd44b2a47142f2fa546671"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34aea7e92abd44b2a47142f2fa546671">local_m</a> () const</td></tr>
<tr class="separator:a34aea7e92abd44b2a47142f2fa546671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1022e93c172ae09f9f976f769435dc82" id="r_a1022e93c172ae09f9f976f769435dc82"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1022e93c172ae09f9f976f769435dc82">local_n</a> () const</td></tr>
<tr class="separator:a1022e93c172ae09f9f976f769435dc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49c06fe686f8b2de01a1cec28a3afb2" id="r_ab49c06fe686f8b2de01a1cec28a3afb2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab49c06fe686f8b2de01a1cec28a3afb2">global_row</a> (const unsigned int loc_row) const</td></tr>
<tr class="separator:ab49c06fe686f8b2de01a1cec28a3afb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11af4d9095e63de77c07fbcf1b34f367" id="r_a11af4d9095e63de77c07fbcf1b34f367"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11af4d9095e63de77c07fbcf1b34f367">global_column</a> (const unsigned int loc_column) const</td></tr>
<tr class="separator:a11af4d9095e63de77c07fbcf1b34f367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8c6ee8de8a5891548743f50325b48d" id="r_a0b8c6ee8de8a5891548743f50325b48d"><td class="memItemLeft" align="right" valign="top">NumberType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b8c6ee8de8a5891548743f50325b48d">local_el</a> (const unsigned int loc_row, const unsigned int loc_column) const</td></tr>
<tr class="separator:a0b8c6ee8de8a5891548743f50325b48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112944e3abfbe79f60b311a170a60de9" id="r_a112944e3abfbe79f60b311a170a60de9"><td class="memItemLeft" align="right" valign="top">NumberType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a112944e3abfbe79f60b311a170a60de9">local_el</a> (const unsigned int loc_row, const unsigned int loc_column)</td></tr>
<tr class="separator:a112944e3abfbe79f60b311a170a60de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e90313134e463ddf7374ee2023ba032" id="r_a6e90313134e463ddf7374ee2023ba032"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e90313134e463ddf7374ee2023ba032">compute_cholesky_factorization</a> ()</td></tr>
<tr class="separator:a6e90313134e463ddf7374ee2023ba032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce68e532d59d501135b8c49f0ad174f" id="r_a8ce68e532d59d501135b8c49f0ad174f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ce68e532d59d501135b8c49f0ad174f">compute_lu_factorization</a> ()</td></tr>
<tr class="separator:a8ce68e532d59d501135b8c49f0ad174f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e064ead5d748e9bfab51124535c735" id="r_a86e064ead5d748e9bfab51124535c735"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86e064ead5d748e9bfab51124535c735">invert</a> ()</td></tr>
<tr class="separator:a86e064ead5d748e9bfab51124535c735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1e407c313486935ec3721ab3a964f8" id="r_aab1e407c313486935ec3721ab3a964f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab1e407c313486935ec3721ab3a964f8">scale_columns</a> (const std::vector&lt; NumberType &gt; &amp;factors)</td></tr>
<tr class="separator:aab1e407c313486935ec3721ab3a964f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a0e3fdc8f1fd82872b936b8f411512" id="r_af2a0e3fdc8f1fd82872b936b8f411512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2a0e3fdc8f1fd82872b936b8f411512">scale_rows</a> (const std::vector&lt; NumberType &gt; &amp;factors)</td></tr>
<tr class="separator:af2a0e3fdc8f1fd82872b936b8f411512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc3849a2ce63c21eff33ed6c31ce0b3" id="r_a8bc3849a2ce63c21eff33ed6c31ce0b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bc3849a2ce63c21eff33ed6c31ce0b3">scale_columns_realfactors</a> (const std::vector&lt; double &gt; &amp;factors)</td></tr>
<tr class="separator:a8bc3849a2ce63c21eff33ed6c31ce0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9281a7b0cfbe3a779e09aa5312229488" id="r_a9281a7b0cfbe3a779e09aa5312229488"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9281a7b0cfbe3a779e09aa5312229488">scale_rows_realfactors</a> (const std::vector&lt; double &gt; &amp;factors)</td></tr>
<tr class="separator:a9281a7b0cfbe3a779e09aa5312229488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81dd4d98eafdd4fe40db0b0133f2165" id="r_aa81dd4d98eafdd4fe40db0b0133f2165"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa81dd4d98eafdd4fe40db0b0133f2165">eigenpairs_hermitian_by_index</a> (const std::pair&lt; unsigned int, unsigned int &gt; &amp;index_limits, const bool compute_eigenvectors)</td></tr>
<tr class="separator:aa81dd4d98eafdd4fe40db0b0133f2165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5599c27fc237ac7e69999ba6d7d913d9" id="r_a5599c27fc237ac7e69999ba6d7d913d9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5599c27fc237ac7e69999ba6d7d913d9">eigenpairs_hermitian_by_index_MRRR</a> (const std::pair&lt; unsigned int, unsigned int &gt; &amp;index_limits, const bool compute_eigenvectors)</td></tr>
<tr class="separator:a5599c27fc237ac7e69999ba6d7d913d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:af889f3eab21c47bee9dd4019a5db9c5a" id="r_af889f3eab21c47bee9dd4019a5db9c5a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af889f3eab21c47bee9dd4019a5db9c5a">eigenpairs_hermitian</a> (const bool compute_eigenvectors, const std::pair&lt; unsigned int, unsigned int &gt; &amp;index_limits=std::make_pair(dealii::numbers::invalid_unsigned_int, dealii::numbers::invalid_unsigned_int), const std::pair&lt; double, double &gt; &amp;value_limits=std::make_pair(std::numeric_limits&lt; double &gt;::quiet_NaN(), std::numeric_limits&lt; double &gt;::quiet_NaN()))</td></tr>
<tr class="separator:af889f3eab21c47bee9dd4019a5db9c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ae288a0acc2add361f98cfe8312aa8" id="r_ab4ae288a0acc2add361f98cfe8312aa8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4ae288a0acc2add361f98cfe8312aa8">eigenpairs_hermitian_MRRR</a> (const bool compute_eigenvectors, const std::pair&lt; unsigned int, unsigned int &gt; &amp;index_limits=std::make_pair(dealii::numbers::invalid_unsigned_int, dealii::numbers::invalid_unsigned_int), const std::pair&lt; double, double &gt; &amp;value_limits=std::make_pair(std::numeric_limits&lt; double &gt;::quiet_NaN(), std::numeric_limits&lt; double &gt;::quiet_NaN()))</td></tr>
<tr class="separator:ab4ae288a0acc2add361f98cfe8312aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a17d00924f0fcea84daf1de84d669654f" id="r_a17d00924f0fcea84daf1de84d669654f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; NumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17d00924f0fcea84daf1de84d669654f">values</a></td></tr>
<tr class="separator:a17d00924f0fcea84daf1de84d669654f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f0c297eb4bf18aabc413b2b698c5af" id="r_a92f0c297eb4bf18aabc413b2b698c5af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#a50176057fe971f54ce6bddd1f09e6d06">dftfe::LAPACKSupport::State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92f0c297eb4bf18aabc413b2b698c5af">state</a></td></tr>
<tr class="separator:a92f0c297eb4bf18aabc413b2b698c5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c818961322247597311ada36af4c6b7" id="r_a0c818961322247597311ada36af4c6b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9ac">dftfe::LAPACKSupport::Property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c818961322247597311ada36af4c6b7">property</a></td></tr>
<tr class="separator:a0c818961322247597311ada36af4c6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6dd32bd3f44887d3833ee19fcc44bd" id="r_a2b6dd32bd3f44887d3833ee19fcc44bd"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdftfe_1_1_process_grid.html">dftfe::ProcessGrid</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b6dd32bd3f44887d3833ee19fcc44bd">grid</a></td></tr>
<tr class="separator:a2b6dd32bd3f44887d3833ee19fcc44bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b24efb278a43b1696a379a2b332bab" id="r_a45b24efb278a43b1696a379a2b332bab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45b24efb278a43b1696a379a2b332bab">n_rows</a></td></tr>
<tr class="separator:a45b24efb278a43b1696a379a2b332bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d09a13a0bedeeb0e38abc743584d2c" id="r_a63d09a13a0bedeeb0e38abc743584d2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63d09a13a0bedeeb0e38abc743584d2c">n_columns</a></td></tr>
<tr class="separator:a63d09a13a0bedeeb0e38abc743584d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49f03ec236b08f7670343cf072f912d" id="r_ac49f03ec236b08f7670343cf072f912d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac49f03ec236b08f7670343cf072f912d">row_block_size</a></td></tr>
<tr class="separator:ac49f03ec236b08f7670343cf072f912d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16408c54c2082adfbca8c7a143f5028" id="r_ab16408c54c2082adfbca8c7a143f5028"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab16408c54c2082adfbca8c7a143f5028">column_block_size</a></td></tr>
<tr class="separator:ab16408c54c2082adfbca8c7a143f5028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cb492c0c59c42dcc736ed44e51bd19" id="r_ac2cb492c0c59c42dcc736ed44e51bd19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2cb492c0c59c42dcc736ed44e51bd19">n_local_rows</a></td></tr>
<tr class="separator:ac2cb492c0c59c42dcc736ed44e51bd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d39f988166252b4f4a3347ea9bb97e6" id="r_a6d39f988166252b4f4a3347ea9bb97e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d39f988166252b4f4a3347ea9bb97e6">n_local_columns</a></td></tr>
<tr class="separator:a6d39f988166252b4f4a3347ea9bb97e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e8ef421c85085add7e872f8f909f64" id="r_ad1e8ef421c85085add7e872f8f909f64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1e8ef421c85085add7e872f8f909f64">descriptor</a> [9]</td></tr>
<tr class="separator:ad1e8ef421c85085add7e872f8f909f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09defcc09c77964515a883863d4db5d2" id="r_a09defcc09c77964515a883863d4db5d2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; NumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09defcc09c77964515a883863d4db5d2">work</a></td></tr>
<tr class="separator:a09defcc09c77964515a883863d4db5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b06a7b0b749dda371a610d5ef31b3b" id="r_a73b06a7b0b749dda371a610d5ef31b3b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73b06a7b0b749dda371a610d5ef31b3b">iwork</a></td></tr>
<tr class="separator:a73b06a7b0b749dda371a610d5ef31b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2005c068c6ebfb84b9b96827e40675d6" id="r_a2005c068c6ebfb84b9b96827e40675d6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2005c068c6ebfb84b9b96827e40675d6">ipiv</a></td></tr>
<tr class="separator:a2005c068c6ebfb84b9b96827e40675d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47f6241046a290b56afe3015f68d562" id="r_ad47f6241046a290b56afe3015f68d562"><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad47f6241046a290b56afe3015f68d562">uplo</a></td></tr>
<tr class="separator:ad47f6241046a290b56afe3015f68d562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97503a5c7979bb0dc1fb4255c261f4a" id="r_ae97503a5c7979bb0dc1fb4255c261f4a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae97503a5c7979bb0dc1fb4255c261f4a">first_process_row</a></td></tr>
<tr class="separator:ae97503a5c7979bb0dc1fb4255c261f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3182cb7ef74187d6653acf1a0f631a5" id="r_ac3182cb7ef74187d6653acf1a0f631a5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3182cb7ef74187d6653acf1a0f631a5">first_process_column</a></td></tr>
<tr class="separator:ac3182cb7ef74187d6653acf1a0f631a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0ce8a69e77fa11614929042bd3e276" id="r_a8d0ce8a69e77fa11614929042bd3e276"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d0ce8a69e77fa11614929042bd3e276">submatrix_row</a></td></tr>
<tr class="separator:a8d0ce8a69e77fa11614929042bd3e276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8bdfe5c541d0464e16ed95c56b00e0" id="r_aac8bdfe5c541d0464e16ed95c56b00e0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac8bdfe5c541d0464e16ed95c56b00e0">submatrix_column</a></td></tr>
<tr class="separator:aac8bdfe5c541d0464e16ed95c56b00e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ba2bb657ecfddf57a777ef0b15ccab" id="r_a69ba2bb657ecfddf57a777ef0b15ccab"><td class="memItemLeft" align="right" valign="top">dealii::Threads::Mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69ba2bb657ecfddf57a777ef0b15ccab">mutex</a></td></tr>
<tr class="separator:a69ba2bb657ecfddf57a777ef0b15ccab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename NumberType&gt;<br />
class dftfe::ScaLAPACKMatrix&lt; NumberType &gt;</div><p>Scalapack wrapper adapted from dealii library and extended implementation to complex datatype. </p>
<dl class="section author"><dt>Author</dt><dd>Sambit Das </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a4caf4c02adc2c4ab39026a39be6b243a" name="a4caf4c02adc2c4ab39026a39be6b243a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4caf4c02adc2c4ab39026a39be6b243a">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::size_type = unsigned int</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare the type for container size. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a877a61dc7a8aa371b9f7655268cf4cd3" name="a877a61dc7a8aa371b9f7655268cf4cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877a61dc7a8aa371b9f7655268cf4cd3">&#9670;&#160;</a></span>ScaLAPACKMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::ScaLAPACKMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>n_rows</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>n_columns</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdftfe_1_1_process_grid.html">dftfe::ProcessGrid</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>process_grid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>row_block_size</em><span class="paramdefsep"> = </span><span class="paramdefval">32</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>column_block_size</em><span class="paramdefsep"> = </span><span class="paramdefval">32</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9ac">dftfe::LAPACKSupport::Property</a></td>          <td class="paramname"><span class="paramname"><em>property</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9aca63df404db8dd3aaa130bb72937c25107">dftfe::LAPACKSupport::Property::general</a></span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for a rectangular matrix with <code>n_rows</code> and <code>n_cols</code> and distributed using the grid <code>process_grid</code>.</p>
<p>The parameters <code>row_block_size</code> and <code>column_block_size</code> are the block sizes used for the block-cyclic distribution of the matrix. In general, it is recommended to use powers of $2$, e.g. $16,32,64, \dots$. </p>

</div>
</div>
<a id="a6025e77abed29ca914a56ae5e11f00e0" name="a6025e77abed29ca914a56ae5e11f00e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6025e77abed29ca914a56ae5e11f00e0">&#9670;&#160;</a></span>ScaLAPACKMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::ScaLAPACKMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdftfe_1_1_process_grid.html">dftfe::ProcessGrid</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>process_grid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>block_size</em><span class="paramdefsep"> = </span><span class="paramdefval">32</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9ac">dftfe::LAPACKSupport::Property</a></td>          <td class="paramname"><span class="paramname"><em>property</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9acacb022b5e749ecd8aded585fa69365425">dftfe::LAPACKSupport::Property::hermitian</a></span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for a square matrix of size <code>size</code>, and distributed using the process grid in <code>process_grid</code>.</p>
<p>The parameter <code>block_size</code> is used for the block-cyclic distribution of the matrix. An identical block size is used for the rows and columns of the matrix. In general, it is recommended to use powers of $2$, e.g. $16,32,64, \dots$. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a42d20c5ad908996be22d9bc6a452e5d4" name="a42d20c5ad908996be22d9bc6a452e5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d20c5ad908996be22d9bc6a452e5d4">&#9670;&#160;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NumberType</td>          <td class="paramname"><span class="paramname"><em>a</em><span class="paramdefsep"> = </span><span class="paramdefval">0.</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NumberType</td>          <td class="paramname"><span class="paramname"><em>b</em><span class="paramdefsep"> = </span><span class="paramdefval">1.</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>transpose_B</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The operations based on the input parameter <code>transpose_B</code> and the alignment conditions are summarized in the following table:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">transpose_B   </th><th class="markdownTableHeadCenter">Block Sizes   </th><th class="markdownTableHeadCenter">Operation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">false   </td><td class="markdownTableBodyCenter">$MB_A=MB_B$ <br  />
 $NB_A=NB_B$   </td><td class="markdownTableBodyCenter">$\mathbf{A} = a \mathbf{A} + b \mathbf{B}$    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">true   </td><td class="markdownTableBodyCenter">$MB_A=NB_B$ <br  />
 $NB_A=MB_B$   </td><td class="markdownTableBodyCenter">$\mathbf{A} = a \mathbf{A} + b \mathbf{B}^T$   </td></tr>
</table>
<p>The matrices $\mathbf{A}$ and $\mathbf{B}$ must have the same process grid. </p>

</div>
</div>
<a id="a6e90313134e463ddf7374ee2023ba032" name="a6e90313134e463ddf7374ee2023ba032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e90313134e463ddf7374ee2023ba032">&#9670;&#160;</a></span>compute_cholesky_factorization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::compute_cholesky_factorization </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Cholesky factorization of the matrix using ScaLAPACK function <code>pXpotrf</code>. The result of the factorization is stored in this object. </p>

</div>
</div>
<a id="a8ce68e532d59d501135b8c49f0ad174f" name="a8ce68e532d59d501135b8c49f0ad174f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce68e532d59d501135b8c49f0ad174f">&#9670;&#160;</a></span>compute_lu_factorization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::compute_lu_factorization </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the LU factorization of the matrix using ScaLAPACK function <code>pXgetrf</code> and partial pivoting with row interchanges. The result of the factorization is stored in this object. </p>

</div>
</div>
<a id="a46ffac5802f6c8aa4e4f8faf739b85f7" name="a46ffac5802f6c8aa4e4f8faf739b85f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ffac5802f6c8aa4e4f8faf739b85f7">&#9670;&#160;</a></span>conjugate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::conjugate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Complex conjugate. </p>

</div>
</div>
<a id="a04dd4e08159c26e5fae262f9ca8dc183" name="a04dd4e08159c26e5fae262f9ca8dc183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04dd4e08159c26e5fae262f9ca8dc183">&#9670;&#160;</a></span>copy_conjugate_transposed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::copy_conjugate_transposed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transposing assignment: $\mathbf{A} = \mathbf{B}^C$</p>
<p>The matrices $\mathbf{A}$ and $\mathbf{B}$ must have the same process grid.</p>
<p>The following alignment conditions have to be fulfilled: $MB_A=NB_B$ and $NB_A=MB_B$. </p>

</div>
</div>
<a id="a2b846add6ba88a8e9b1f1af7750e3a9c" name="a2b846add6ba88a8e9b1f1af7750e3a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b846add6ba88a8e9b1f1af7750e3a9c">&#9670;&#160;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the contents of the distributed matrix into a differently distributed matrix <code>dest</code>. The function also works for matrices with different process grids or block-cyclic distributions. </p>

</div>
</div>
<a id="ab607c0944accd8bc9b549e43c57f695a" name="ab607c0944accd8bc9b549e43c57f695a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab607c0944accd8bc9b549e43c57f695a">&#9670;&#160;</a></span>copy_transposed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::copy_transposed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transposing assignment: $\mathbf{A} = \mathbf{B}^T$</p>
<p>The matrices $\mathbf{A}$ and $\mathbf{B}$ must have the same process grid.</p>
<p>The following alignment conditions have to be fulfilled: $MB_A=NB_B$ and $NB_A=MB_B$. </p>

</div>
</div>
<a id="af889f3eab21c47bee9dd4019a5db9c5a" name="af889f3eab21c47bee9dd4019a5db9c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af889f3eab21c47bee9dd4019a5db9c5a">&#9670;&#160;</a></span>eigenpairs_hermitian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::eigenpairs_hermitian </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>compute_eigenvectors</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; unsigned int, unsigned int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>index_limits</em><span class="paramdefsep"> = </span><span class="paramdefval">std::make_pair(dealii::numbers::invalid_unsigned_int,&#160;dealii::numbers::invalid_unsigned_int)</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; double, double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value_limits</em><span class="paramdefsep"> = </span><span class="paramdefval">std::make_pair(std::numeric_limits&lt;&#160;double&#160;&gt;::quiet_NaN(),&#160;std::numeric_limits&lt;&#160;double&#160;&gt;::quiet_NaN())</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computing selected eigenvalues and, optionally, the eigenvectors. The eigenvalues/eigenvectors are selected by either prescribing a range of indices <code>index_limits</code> or a range of values <code>value_limits</code> for the eigenvalues. The function will throw an exception if both ranges are prescribed (meaning that both ranges differ from the default value) as this ambiguity is prohibited. If successful, the computed eigenvalues are arranged in ascending order. The eigenvectors are stored in the columns of the matrix, thereby overwriting the original content of the matrix. </p>

</div>
</div>
<a id="aa81dd4d98eafdd4fe40db0b0133f2165" name="aa81dd4d98eafdd4fe40db0b0133f2165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81dd4d98eafdd4fe40db0b0133f2165">&#9670;&#160;</a></span>eigenpairs_hermitian_by_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::eigenpairs_hermitian_by_index </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; unsigned int, unsigned int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>index_limits</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>compute_eigenvectors</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computing selected eigenvalues and, optionally, the eigenvectors of the real hermitian matrix $\mathbf{A} \in \mathbb{R}^{M \times M}$.</p>
<p>The eigenvalues/eigenvectors are selected by prescribing a range of indices <code>index_limits</code>.</p>
<p>If successful, the computed eigenvalues are arranged in ascending order. The eigenvectors are stored in the columns of the matrix, thereby overwriting the original content of the matrix.</p>
<p>If all eigenvalues/eigenvectors have to be computed, pass the closed interval $ \left[ 0, M-1 \right] $ in <code>index_limits</code>.</p>
<p>Pass the closed interval $ \left[ M-r, M-1 \right] $ if the $r$ largest eigenvalues/eigenvectors are desired. </p>

</div>
</div>
<a id="a5599c27fc237ac7e69999ba6d7d913d9" name="a5599c27fc237ac7e69999ba6d7d913d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5599c27fc237ac7e69999ba6d7d913d9">&#9670;&#160;</a></span>eigenpairs_hermitian_by_index_MRRR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::eigenpairs_hermitian_by_index_MRRR </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; unsigned int, unsigned int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>index_limits</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>compute_eigenvectors</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computing selected eigenvalues and, optionally, the eigenvectors of the real hermitian matrix $\mathbf{A} \in \mathbb{R}^{M \times M}$ using the MRRR algorithm.</p>
<p>The eigenvalues/eigenvectors are selected by prescribing a range of indices <code>index_limits</code>.</p>
<p>If successful, the computed eigenvalues are arranged in ascending order. The eigenvectors are stored in the columns of the matrix, thereby overwriting the original content of the matrix.</p>
<p>If all eigenvalues/eigenvectors have to be computed, pass the closed interval $ \left[ 0, M-1 \right] $ in <code>index_limits</code>.</p>
<p>Pass the closed interval $ \left[ M-r, M-1 \right] $ if the $r$ largest eigenvalues/eigenvectors are desired. </p>

</div>
</div>
<a id="ab4ae288a0acc2add361f98cfe8312aa8" name="ab4ae288a0acc2add361f98cfe8312aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ae288a0acc2add361f98cfe8312aa8">&#9670;&#160;</a></span>eigenpairs_hermitian_MRRR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::eigenpairs_hermitian_MRRR </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>compute_eigenvectors</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; unsigned int, unsigned int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>index_limits</em><span class="paramdefsep"> = </span><span class="paramdefval">std::make_pair(dealii::numbers::invalid_unsigned_int,&#160;dealii::numbers::invalid_unsigned_int)</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; double, double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value_limits</em><span class="paramdefsep"> = </span><span class="paramdefval">std::make_pair(std::numeric_limits&lt;&#160;double&#160;&gt;::quiet_NaN(),&#160;std::numeric_limits&lt;&#160;double&#160;&gt;::quiet_NaN())</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computing selected eigenvalues and, optionally, the eigenvectors of the real hermitian matrix $\mathbf{A} \in \mathbb{R}^{M \times M}$ using the MRRR algorithm. The eigenvalues/eigenvectors are selected by either prescribing a range of indices <code>index_limits</code> or a range of values <code>value_limits</code> for the eigenvalues. The function will throw an exception if both ranges are prescribed (meaning that both ranges differ from the default value) as this ambiguity is prohibited.</p>
<p>By calling this function the original content of the matrix will be overwritten. If requested, the eigenvectors are stored in the columns of the matrix. Also in the case that just the eigenvalues are required, the content of the matrix will be overwritten.</p>
<p>If successful, the computed eigenvalues are arranged in ascending order.</p>
<dl class="section note"><dt>Note</dt><dd>Due to a bug in Netlib-ScaLAPACK, either all or no eigenvectors can be computed. Therefore, the input <code>index_limits</code> has to be set accordingly. Using Intel-MKL this restriction is not required. </dd></dl>

</div>
</div>
<a id="a6213590579de7473604c7b7fc7fb1dcc" name="a6213590579de7473604c7b7fc7fb1dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6213590579de7473604c7b7fc7fb1dcc">&#9670;&#160;</a></span>get_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9ac">dftfe::LAPACKSupport::Property</a> <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::get_property </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return current <code>property</code> of this matrix </p>

</div>
</div>
<a id="a1b6277fcc0a927bb6bed309eaaef18cc" name="a1b6277fcc0a927bb6bed309eaaef18cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6277fcc0a927bb6bed309eaaef18cc">&#9670;&#160;</a></span>get_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#a50176057fe971f54ce6bddd1f09e6d06">dftfe::LAPACKSupport::State</a> <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::get_state </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return current <code>state</code> of this matrix </p>

</div>
</div>
<a id="a11af4d9095e63de77c07fbcf1b34f367" name="a11af4d9095e63de77c07fbcf1b34f367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11af4d9095e63de77c07fbcf1b34f367">&#9670;&#160;</a></span>global_column()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::global_column </td>
          <td>(</td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>loc_column</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the global column number for the given local column <code>loc_column</code>. </p>

</div>
</div>
<a id="ab49c06fe686f8b2de01a1cec28a3afb2" name="ab49c06fe686f8b2de01a1cec28a3afb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49c06fe686f8b2de01a1cec28a3afb2">&#9670;&#160;</a></span>global_row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::global_row </td>
          <td>(</td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>loc_row</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the global row number for the given local row <code>loc_row</code> . </p>

</div>
</div>
<a id="a86e064ead5d748e9bfab51124535c735" name="a86e064ead5d748e9bfab51124535c735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e064ead5d748e9bfab51124535c735">&#9670;&#160;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::invert </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invert the matrix by first computing a Cholesky for hermitian matrices or a LU factorization for general matrices and then building the actual inverse using <code>pXpotri</code> or <code>pXgetri</code>. If the matrix is triangular, the LU factorization step is skipped, and <code>pXtrtri</code> is used directly.</p>
<p>If a Cholesky or LU factorization has been applied previously, <code>pXpotri</code> or <code>pXgetri</code> are called directly.</p>
<p>The inverse is stored in this object. </p>

</div>
</div>
<a id="a112944e3abfbe79f60b311a170a60de9" name="a112944e3abfbe79f60b311a170a60de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112944e3abfbe79f60b311a170a60de9">&#9670;&#160;</a></span>local_el() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NumberType &amp; <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::local_el </td>
          <td>(</td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>loc_row</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>loc_column</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write access to local element. </p>

</div>
</div>
<a id="a0b8c6ee8de8a5891548743f50325b48d" name="a0b8c6ee8de8a5891548743f50325b48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8c6ee8de8a5891548743f50325b48d">&#9670;&#160;</a></span>local_el() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NumberType <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::local_el </td>
          <td>(</td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>loc_row</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>loc_column</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read access to local element. </p>

</div>
</div>
<a id="a34aea7e92abd44b2a47142f2fa546671" name="a34aea7e92abd44b2a47142f2fa546671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34aea7e92abd44b2a47142f2fa546671">&#9670;&#160;</a></span>local_m()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::local_m </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of local rows on this MPI processes. </p>

</div>
</div>
<a id="a1022e93c172ae09f9f976f769435dc82" name="a1022e93c172ae09f9f976f769435dc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1022e93c172ae09f9f976f769435dc82">&#9670;&#160;</a></span>local_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::local_n </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of local columns on this MPI process. </p>

</div>
</div>
<a id="a58e8a50bfee69f4bf767b41fd4621f52" name="a58e8a50bfee69f4bf767b41fd4621f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e8a50bfee69f4bf767b41fd4621f52">&#9670;&#160;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::m </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of rows of the $M \times N$ matrix. </p>

</div>
</div>
<a id="ab9cde52bed9faa050dce904c96eebce0" name="ab9cde52bed9faa050dce904c96eebce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cde52bed9faa050dce904c96eebce0">&#9670;&#160;</a></span>mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>adding</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix-multiplication.</p>
<p>The optional parameter <code>adding</code> determines whether the result is stored in $\mathbf{C}$ or added to $\mathbf{C}$.</p>
<p>if (<code>adding</code>) $\mathbf{C} = \mathbf{C} + \mathbf{A} \cdot \mathbf{B}$</p>
<p>else $\mathbf{C} = \mathbf{A} \cdot \mathbf{B}$</p>
<p>It is assumed that $\mathbf{A}$ and $\mathbf{B}$ have compatible sizes and that $\mathbf{C}$ already has the right size.</p>
<p>The following alignment conditions have to be fulfilled: $MB_A=MB_C$, $NB_A=MB_B$ and $NB_B=NB_C$. </p>

</div>
</div>
<a id="a707a28c545abba69394929b0ff934fdd" name="a707a28c545abba69394929b0ff934fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707a28c545abba69394929b0ff934fdd">&#9670;&#160;</a></span>mTmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::mTmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>adding</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix-multiplication using the transpose of $\mathbf{B}$.</p>
<p>The optional parameter <code>adding</code> determines whether the result is stored in $\mathbf{C}$ or added to $\mathbf{C}$.</p>
<p>if (<code>adding</code>) $\mathbf{C} = \mathbf{C} + \mathbf{A} \cdot \mathbf{B}^T$</p>
<p>else $\mathbf{C} = \mathbf{A} \cdot \mathbf{B}^T$</p>
<p>It is assumed that $\mathbf{A}$ and $\mathbf{B}$ have compatible sizes and that $\mathbf{C}$ already has the right size.</p>
<p>The following alignment conditions have to be fulfilled: $MB_A=MB_C$, $NB_A=NB_B$ and $MB_B=NB_C$. </p>

</div>
</div>
<a id="a245caef57db69751ecdebc120ff4b456" name="a245caef57db69751ecdebc120ff4b456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245caef57db69751ecdebc120ff4b456">&#9670;&#160;</a></span>mult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::mult </td>
          <td>(</td>
          <td class="paramtype">const NumberType</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NumberType</td>          <td class="paramname"><span class="paramname"><em>c</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>transpose_A</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>transpose_B</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix-multiplication:</p>
<p>The operations based on the input parameters and the alignment conditions are summarized in the following table:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">transpose_A   </th><th class="markdownTableHeadCenter">transpose_B   </th><th class="markdownTableHeadCenter">Block Sizes   </th><th class="markdownTableHeadCenter">Operation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">false   </td><td class="markdownTableBodyCenter">false   </td><td class="markdownTableBodyCenter">$MB_A=MB_C$ <br  />
 $NB_A=MB_B$ <br  />
 $NB_B=NB_C$   </td><td class="markdownTableBodyCenter">$\mathbf{C} = b \mathbf{A} \cdot \mathbf{B} + c \mathbf{C}$    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">false   </td><td class="markdownTableBodyCenter">true   </td><td class="markdownTableBodyCenter">$MB_A=MB_C$ <br  />
 $NB_A=NB_B$ <br  />
 $MB_B=NB_C$   </td><td class="markdownTableBodyCenter">$\mathbf{C} = b \mathbf{A} \cdot \mathbf{B}^T + c \mathbf{C}$    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">true   </td><td class="markdownTableBodyCenter">false   </td><td class="markdownTableBodyCenter">$MB_A=MB_B$ <br  />
 $NB_A=MB_C$ <br  />
 $NB_B=NB_C$   </td><td class="markdownTableBodyCenter">$\mathbf{C} = b \mathbf{A}^T \cdot \mathbf{B} + c \mathbf{C}$    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">true   </td><td class="markdownTableBodyCenter">true   </td><td class="markdownTableBodyCenter">$MB_A=NB_B$ <br  />
 $NB_A=MB_C$ <br  />
 $MB_B=NB_C$   </td><td class="markdownTableBodyCenter">$\mathbf{C} = b \mathbf{A}^T \cdot \mathbf{B}^T + c \mathbf{C}$   </td></tr>
</table>
<p>It is assumed that $\mathbf{A}$ and $\mathbf{B}$ have compatible sizes and that $\mathbf{C}$ already has the right size.</p>
<p>The matrices $\mathbf{A}$, $\mathbf{B}$ and $\mathbf{C}$ must have the same process grid. </p>

</div>
</div>
<a id="a41c494fd3964387d621a45c8f25e664d" name="a41c494fd3964387d621a45c8f25e664d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c494fd3964387d621a45c8f25e664d">&#9670;&#160;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::n </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of columns of the $M \times N$ matrix. </p>

</div>
</div>
<a id="a1a08450144cb221e7ebaa5cf0ba1a02b" name="a1a08450144cb221e7ebaa5cf0ba1a02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a08450144cb221e7ebaa5cf0ba1a02b">&#9670;&#160;</a></span>reinit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>n_rows</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>n_columns</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdftfe_1_1_process_grid.html">dftfe::ProcessGrid</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>process_grid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>row_block_size</em><span class="paramdefsep"> = </span><span class="paramdefval">32</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>column_block_size</em><span class="paramdefsep"> = </span><span class="paramdefval">32</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9ac">dftfe::LAPACKSupport::Property</a></td>          <td class="paramname"><span class="paramname"><em>property</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9aca63df404db8dd3aaa130bb72937c25107">dftfe::LAPACKSupport::Property::general</a></span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the rectangular matrix with <code>n_rows</code> and <code>n_cols</code> and distributed using the grid <code>process_grid</code>.</p>
<p>The parameters <code>row_block_size</code> and <code>column_block_size</code> are the block sizes used for the block-cyclic distribution of the matrix. In general, it is recommended to use powers of $2$, e.g. $16,32,64, \dots$. </p>

</div>
</div>
<a id="a1144c2f751a2e2d6245dcde85d9958d1" name="a1144c2f751a2e2d6245dcde85d9958d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1144c2f751a2e2d6245dcde85d9958d1">&#9670;&#160;</a></span>reinit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdftfe_1_1_process_grid.html">dftfe::ProcessGrid</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>process_grid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a4caf4c02adc2c4ab39026a39be6b243a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>block_size</em><span class="paramdefsep"> = </span><span class="paramdefval">32</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9ac">dftfe::LAPACKSupport::Property</a></td>          <td class="paramname"><span class="paramname"><em>property</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9acacb022b5e749ecd8aded585fa69365425">dftfe::LAPACKSupport::Property::hermitian</a></span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the square matrix of size <code>size</code> and distributed using the grid <code>process_grid</code>.</p>
<p>The parameter <code>block_size</code> is used for the block-cyclic distribution of the matrix. An identical block size is used for the rows and columns of the matrix. In general, it is recommended to use powers of $2$, e.g. $16,32,64, \dots$. </p>

</div>
</div>
<a id="aab1e407c313486935ec3721ab3a964f8" name="aab1e407c313486935ec3721ab3a964f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1e407c313486935ec3721ab3a964f8">&#9670;&#160;</a></span>scale_columns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::scale_columns </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>factors</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale the columns of the distributed matrix by the scalars provided in the array <code>factors</code>.</p>
<p>The array <code>factors</code> must have as many entries as the matrix columns.</p>
<p>Copies of <code>factors</code> have to be available on all processes of the underlying MPI communicator. </p>

</div>
</div>
<a id="a8bc3849a2ce63c21eff33ed6c31ce0b3" name="a8bc3849a2ce63c21eff33ed6c31ce0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc3849a2ce63c21eff33ed6c31ce0b3">&#9670;&#160;</a></span>scale_columns_realfactors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::scale_columns_realfactors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>factors</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale the columns of the distributed matrix by the scalars provided in the array <code>factors</code>.</p>
<p>The array <code>factors</code> must have as many entries as the matrix columns.</p>
<p>Copies of <code>factors</code> have to be available on all processes of the underlying MPI communicator. </p>

</div>
</div>
<a id="af2a0e3fdc8f1fd82872b936b8f411512" name="af2a0e3fdc8f1fd82872b936b8f411512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a0e3fdc8f1fd82872b936b8f411512">&#9670;&#160;</a></span>scale_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::scale_rows </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>factors</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale the rows of the distributed matrix by the scalars provided in the array <code>factors</code>.</p>
<p>The array <code>factors</code> must have as many entries as the matrix rows.</p>
<p>Copies of <code>factors</code> have to be available on all processes of the underlying MPI communicator. </p>

</div>
</div>
<a id="a9281a7b0cfbe3a779e09aa5312229488" name="a9281a7b0cfbe3a779e09aa5312229488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9281a7b0cfbe3a779e09aa5312229488">&#9670;&#160;</a></span>scale_rows_realfactors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::scale_rows_realfactors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>factors</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale the rows of the distributed matrix by the scalars provided in the array <code>factors</code>.</p>
<p>The array <code>factors</code> must have as many entries as the matrix rows.</p>
<p>Copies of <code>factors</code> have to be available on all processes of the underlying MPI communicator. </p>

</div>
</div>
<a id="a5c7da23c4243e9ace668a66239039bed" name="a5c7da23c4243e9ace668a66239039bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7da23c4243e9ace668a66239039bed">&#9670;&#160;</a></span>set_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::set_property </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9ac">dftfe::LAPACKSupport::Property</a></td>          <td class="paramname"><span class="paramname"><em>property</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign <code>property</code> to this matrix. </p>

</div>
</div>
<a id="a6f9a582f73de96239b2ffa4ead2934cd" name="a6f9a582f73de96239b2ffa4ead2934cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9a582f73de96239b2ffa4ead2934cd">&#9670;&#160;</a></span>Tmmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>adding</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix-multiplication using transpose of $\mathbf{A}$.</p>
<p>The optional parameter <code>adding</code> determines whether the result is stored in $\mathbf{C}$ or added to $\mathbf{C}$.</p>
<p>if (<code>adding</code>) $\mathbf{C} = \mathbf{C} + \mathbf{A}^T \cdot \mathbf{B}$</p>
<p>else $\mathbf{C} = \mathbf{A}^T \cdot \mathbf{B}$</p>
<p>It is assumed that $\mathbf{A}$ and $\mathbf{B}$ have compatible sizes and that $\mathbf{C}$ already has the right size.</p>
<p>The following alignment conditions have to be fulfilled: $MB_A=MB_B$, $NB_A=MB_C$ and $NB_B=NB_C$. </p>

</div>
</div>
<a id="aac663b0fe6a673b3fef08226fdd24d9b" name="aac663b0fe6a673b3fef08226fdd24d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac663b0fe6a673b3fef08226fdd24d9b">&#9670;&#160;</a></span>TmTmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::TmTmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>adding</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix-multiplication using transpose of $\mathbf{A}$ and $\mathbf{B}$.</p>
<p>The optional parameter <code>adding</code> determines whether the result is stored in $\mathbf{C}$ or added to $\mathbf{C}$.</p>
<p>if (<code>adding</code>) $\mathbf{C} = \mathbf{C} + \mathbf{A}^T \cdot \mathbf{B}^T$</p>
<p>else $\mathbf{C} = \mathbf{A}^T \cdot \mathbf{B}^T$</p>
<p>It is assumed that $\mathbf{A}$ and $\mathbf{B}$ have compatible sizes and that $\mathbf{C}$ already has the right size.</p>
<p>The following alignment conditions have to be fulfilled: $MB_A=NB_B$, $NB_A=MB_C$ and $MB_B=NB_C$. </p>

</div>
</div>
<a id="a6b2ff1dc6410222c2fca0d20fe8ef983" name="a6b2ff1dc6410222c2fca0d20fe8ef983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2ff1dc6410222c2fca0d20fe8ef983">&#9670;&#160;</a></span>zadd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::zadd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NumberType</td>          <td class="paramname"><span class="paramname"><em>a</em><span class="paramdefsep"> = </span><span class="paramdefval">0.</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NumberType</td>          <td class="paramname"><span class="paramname"><em>b</em><span class="paramdefsep"> = </span><span class="paramdefval">1.</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>conjugate_transpose_B</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The operations based on the input parameter <code>conjugate_transpose_B</code> and the alignment conditions are summarized in the following table:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">transpose_B   </th><th class="markdownTableHeadCenter">Block Sizes   </th><th class="markdownTableHeadCenter">Operation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">false   </td><td class="markdownTableBodyCenter">$MB_A=MB_B$ <br  />
 $NB_A=NB_B$   </td><td class="markdownTableBodyCenter">$\mathbf{A} = a \mathbf{A} + b \mathbf{B}$    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">true   </td><td class="markdownTableBodyCenter">$MB_A=NB_B$ <br  />
 $NB_A=MB_B$   </td><td class="markdownTableBodyCenter">$\mathbf{A} = a \mathbf{A} + b \mathbf{B}^C$   </td></tr>
</table>
<p>The matrices $\mathbf{A}$ and $\mathbf{B}$ must have the same process grid. </p>

</div>
</div>
<a id="ae3aeb1d84498e30020980c34e3612ea9" name="ae3aeb1d84498e30020980c34e3612ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3aeb1d84498e30020980c34e3612ea9">&#9670;&#160;</a></span>zCmCmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::zCmCmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>adding</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix-multiplication using conjugate transpose of $\mathbf{A}$ and $\mathbf{B}$.</p>
<p>The optional parameter <code>adding</code> determines whether the result is stored in $\mathbf{C}$ or added to $\mathbf{C}$.</p>
<p>if (<code>adding</code>) $\mathbf{C} = \mathbf{C} + \mathbf{A}^C \cdot \mathbf{B}^T$</p>
<p>else $\mathbf{C} = \mathbf{A}^C \cdot \mathbf{B}^C$</p>
<p>It is assumed that $\mathbf{A}$ and $\mathbf{B}$ have compatible sizes and that $\mathbf{C}$ already has the right size.</p>
<p>The following alignment conditions have to be fulfilled: $MB_A=NB_B$, $NB_A=MB_C$ and $MB_B=NB_C$. </p>

</div>
</div>
<a id="a63411b9232cad71c462c8fa9e057bd56" name="a63411b9232cad71c462c8fa9e057bd56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63411b9232cad71c462c8fa9e057bd56">&#9670;&#160;</a></span>zCmmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::zCmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>adding</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix-multiplication using conjugate transpose of $\mathbf{A}$.</p>
<p>The optional parameter <code>adding</code> determines whether the result is stored in $\mathbf{C}$ or added to $\mathbf{C}$.</p>
<p>if (<code>adding</code>) $\mathbf{C} = \mathbf{C} + \mathbf{A}^C \cdot \mathbf{B}$</p>
<p>else $\mathbf{C} = \mathbf{A}^C \cdot \mathbf{B}$</p>
<p>It is assumed that $\mathbf{A}$ and $\mathbf{B}$ have compatible sizes and that $\mathbf{C}$ already has the right size.</p>
<p>The following alignment conditions have to be fulfilled: $MB_A=MB_B$, $NB_A=MB_C$ and $NB_B=NB_C$. </p>

</div>
</div>
<a id="a86f3f5e5913f82d3e303e55728179b90" name="a86f3f5e5913f82d3e303e55728179b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f3f5e5913f82d3e303e55728179b90">&#9670;&#160;</a></span>zmCmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::zmCmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>adding</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix-multiplication using the conjugate transpose of $\mathbf{B}$.</p>
<p>The optional parameter <code>adding</code> determines whether the result is stored in $\mathbf{C}$ or added to $\mathbf{C}$.</p>
<p>if (<code>adding</code>) $\mathbf{C} = \mathbf{C} + \mathbf{A} \cdot \mathbf{B}^C$</p>
<p>else $\mathbf{C} = \mathbf{A} \cdot \mathbf{B}^C$</p>
<p>It is assumed that $\mathbf{A}$ and $\mathbf{B}$ have compatible sizes and that $\mathbf{C}$ already has the right size.</p>
<p>The following alignment conditions have to be fulfilled: $MB_A=MB_C$, $NB_A=NB_B$ and $MB_B=NB_C$. </p>

</div>
</div>
<a id="a2dce63d8bd4dccf4624d41350398107e" name="a2dce63d8bd4dccf4624d41350398107e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dce63d8bd4dccf4624d41350398107e">&#9670;&#160;</a></span>zmmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::zmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>adding</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix-multiplication.</p>
<p>The optional parameter <code>adding</code> determines whether the result is stored in $\mathbf{C}$ or added to $\mathbf{C}$.</p>
<p>if (<code>adding</code>) $\mathbf{C} = \mathbf{C} + \mathbf{A} \cdot \mathbf{B}$</p>
<p>else $\mathbf{C} = \mathbf{A} \cdot \mathbf{B}$</p>
<p>It is assumed that $\mathbf{A}$ and $\mathbf{B}$ have compatible sizes and that $\mathbf{C}$ already has the right size.</p>
<p>The following alignment conditions have to be fulfilled: $MB_A=MB_C$, $NB_A=MB_B$ and $NB_B=NB_C$. </p>

</div>
</div>
<a id="a88d041424c4ab89f58557c1c92e167c0" name="a88d041424c4ab89f58557c1c92e167c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d041424c4ab89f58557c1c92e167c0">&#9670;&#160;</a></span>zmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::zmult </td>
          <td>(</td>
          <td class="paramtype">const NumberType</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NumberType</td>          <td class="paramname"><span class="paramname"><em>c</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>conjugate_transpose_A</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>conjugate_transpose_B</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix-multiplication:</p>
<p>The operations based on the input parameters and the alignment conditions are summarized in the following table:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">conjugate_transpose_A   </th><th class="markdownTableHeadCenter">conjugate_transpose_B   </th><th class="markdownTableHeadCenter">Block Sizes   </th><th class="markdownTableHeadCenter">Operation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">false   </td><td class="markdownTableBodyCenter">false   </td><td class="markdownTableBodyCenter">$MB_A=MB_C$ <br  />
 $NB_A=MB_B$ <br  />
 $NB_B=NB_C$   </td><td class="markdownTableBodyCenter">$\mathbf{C} = b \mathbf{A} \cdot \mathbf{B} + c \mathbf{C}$    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">false   </td><td class="markdownTableBodyCenter">true   </td><td class="markdownTableBodyCenter">$MB_A=MB_C$ <br  />
 $NB_A=NB_B$ <br  />
 $MB_B=NB_C$   </td><td class="markdownTableBodyCenter">$\mathbf{C} = b \mathbf{A} \cdot \mathbf{B}^C + c \mathbf{C}$    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">true   </td><td class="markdownTableBodyCenter">false   </td><td class="markdownTableBodyCenter">$MB_A=MB_B$ <br  />
 $NB_A=MB_C$ <br  />
 $NB_B=NB_C$   </td><td class="markdownTableBodyCenter">$\mathbf{C} = b \mathbf{A}^C \cdot \mathbf{B} + c \mathbf{C}$    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">true   </td><td class="markdownTableBodyCenter">true   </td><td class="markdownTableBodyCenter">$MB_A=NB_B$ <br  />
 $NB_A=MB_C$ <br  />
 $MB_B=NB_C$   </td><td class="markdownTableBodyCenter">$\mathbf{C} = b \mathbf{A}^C \cdot \mathbf{B}^C + c \mathbf{C}$   </td></tr>
</table>
<p>It is assumed that $\mathbf{A}$ and $\mathbf{B}$ have compatible sizes and that $\mathbf{C}$ already has the right size.</p>
<p>The matrices $\mathbf{A}$, $\mathbf{B}$ and $\mathbf{C}$ must have the same process grid. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab16408c54c2082adfbca8c7a143f5028" name="ab16408c54c2082adfbca8c7a143f5028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16408c54c2082adfbca8c7a143f5028">&#9670;&#160;</a></span>column_block_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::column_block_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Column block size. </p>

</div>
</div>
<a id="ad1e8ef421c85085add7e872f8f909f64" name="ad1e8ef421c85085add7e872f8f909f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e8ef421c85085add7e872f8f909f64">&#9670;&#160;</a></span>descriptor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::descriptor[9]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ScaLAPACK description vector. </p>

</div>
</div>
<a id="ac3182cb7ef74187d6653acf1a0f631a5" name="ac3182cb7ef74187d6653acf1a0f631a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3182cb7ef74187d6653acf1a0f631a5">&#9670;&#160;</a></span>first_process_column</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::first_process_column</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The process column of the process grid over which the first column of the global matrix is distributed. </p>

</div>
</div>
<a id="ae97503a5c7979bb0dc1fb4255c261f4a" name="ae97503a5c7979bb0dc1fb4255c261f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97503a5c7979bb0dc1fb4255c261f4a">&#9670;&#160;</a></span>first_process_row</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::first_process_row</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The process row of the process grid over which the first row of the global matrix is distributed. </p>

</div>
</div>
<a id="a2b6dd32bd3f44887d3833ee19fcc44bd" name="a2b6dd32bd3f44887d3833ee19fcc44bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6dd32bd3f44887d3833ee19fcc44bd">&#9670;&#160;</a></span>grid</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdftfe_1_1_process_grid.html">dftfe::ProcessGrid</a>&gt; <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::grid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A shared pointer to a dealii::Utilities::MPI::ProcessGrid object which contains a BLACS context and a MPI communicator, as well as other necessary data structures. </p>

</div>
</div>
<a id="a2005c068c6ebfb84b9b96827e40675d6" name="a2005c068c6ebfb84b9b96827e40675d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2005c068c6ebfb84b9b96827e40675d6">&#9670;&#160;</a></span>ipiv</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::ipiv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Integer array holding pivoting information required by ScaLAPACK's matrix factorization routines. </p>

</div>
</div>
<a id="a73b06a7b0b749dda371a610d5ef31b3b" name="a73b06a7b0b749dda371a610d5ef31b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b06a7b0b749dda371a610d5ef31b3b">&#9670;&#160;</a></span>iwork</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::iwork</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Integer workspace array. </p>

</div>
</div>
<a id="a69ba2bb657ecfddf57a777ef0b15ccab" name="a69ba2bb657ecfddf57a777ef0b15ccab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ba2bb657ecfddf57a777ef0b15ccab">&#9670;&#160;</a></span>mutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dealii::Threads::Mutex <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Thread mutex. </p>

</div>
</div>
<a id="a63d09a13a0bedeeb0e38abc743584d2c" name="a63d09a13a0bedeeb0e38abc743584d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d09a13a0bedeeb0e38abc743584d2c">&#9670;&#160;</a></span>n_columns</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::n_columns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of columns in the matrix. </p>

</div>
</div>
<a id="a6d39f988166252b4f4a3347ea9bb97e6" name="a6d39f988166252b4f4a3347ea9bb97e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d39f988166252b4f4a3347ea9bb97e6">&#9670;&#160;</a></span>n_local_columns</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::n_local_columns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of columns in the matrix owned by the current process. </p>

</div>
</div>
<a id="ac2cb492c0c59c42dcc736ed44e51bd19" name="ac2cb492c0c59c42dcc736ed44e51bd19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cb492c0c59c42dcc736ed44e51bd19">&#9670;&#160;</a></span>n_local_rows</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::n_local_rows</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of rows in the matrix owned by the current process. </p>

</div>
</div>
<a id="a45b24efb278a43b1696a379a2b332bab" name="a45b24efb278a43b1696a379a2b332bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b24efb278a43b1696a379a2b332bab">&#9670;&#160;</a></span>n_rows</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::n_rows</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of rows in the matrix. </p>

</div>
</div>
<a id="a0c818961322247597311ada36af4c6b7" name="a0c818961322247597311ada36af4c6b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c818961322247597311ada36af4c6b7">&#9670;&#160;</a></span>property</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#af3c45dcea64890f047b4dca87fdde9ac">dftfe::LAPACKSupport::Property</a> <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::property</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Additional property of the matrix which may help to select more efficient ScaLAPACK functions. </p>

</div>
</div>
<a id="ac49f03ec236b08f7670343cf072f912d" name="ac49f03ec236b08f7670343cf072f912d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49f03ec236b08f7670343cf072f912d">&#9670;&#160;</a></span>row_block_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::row_block_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Row block size. </p>

</div>
</div>
<a id="a92f0c297eb4bf18aabc413b2b698c5af" name="a92f0c297eb4bf18aabc413b2b698c5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f0c297eb4bf18aabc413b2b698c5af">&#9670;&#160;</a></span>state</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedftfe_1_1_l_a_p_a_c_k_support.html#a50176057fe971f54ce6bddd1f09e6d06">dftfe::LAPACKSupport::State</a> <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Since ScaLAPACK operations notoriously change the meaning of the matrix entries, we record the current state after the last operation here. </p>

</div>
</div>
<a id="aac8bdfe5c541d0464e16ed95c56b00e0" name="aac8bdfe5c541d0464e16ed95c56b00e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8bdfe5c541d0464e16ed95c56b00e0">&#9670;&#160;</a></span>submatrix_column</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::submatrix_column</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global column index that determines where to start a submatrix. Currently this equals unity, as we don't use submatrices. </p>

</div>
</div>
<a id="a8d0ce8a69e77fa11614929042bd3e276" name="a8d0ce8a69e77fa11614929042bd3e276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0ce8a69e77fa11614929042bd3e276">&#9670;&#160;</a></span>submatrix_row</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::submatrix_row</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global row index that determines where to start a submatrix. Currently this equals unity, as we don't use submatrices. </p>

</div>
</div>
<a id="ad47f6241046a290b56afe3015f68d562" name="ad47f6241046a290b56afe3015f68d562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47f6241046a290b56afe3015f68d562">&#9670;&#160;</a></span>uplo</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::uplo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A character to define where elements are stored in case ScaLAPACK operations support this. </p>

</div>
</div>
<a id="a17d00924f0fcea84daf1de84d669654f" name="a17d00924f0fcea84daf1de84d669654f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d00924f0fcea84daf1de84d669654f">&#9670;&#160;</a></span>values</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;NumberType&gt; <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>local storage </p>

</div>
</div>
<a id="a09defcc09c77964515a883863d4db5d2" name="a09defcc09c77964515a883863d4db5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09defcc09c77964515a883863d4db5d2">&#9670;&#160;</a></span>work</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;NumberType&gt; <a class="el" href="classdftfe_1_1_sca_l_a_p_a_c_k_matrix.html">dftfe::ScaLAPACKMatrix</a>&lt; NumberType &gt;::work</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Workspace array. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>workspace/include/<a class="el" href="process__grid_8h_source.html">process_grid.h</a></li>
<li>workspace/include/<a class="el" href="scalapack_wrapper_8h_source.html">scalapackWrapper.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
