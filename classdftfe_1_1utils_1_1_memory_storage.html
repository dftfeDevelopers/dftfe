<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DFT-FE: dftfe::utils::MemoryStorage&lt; ValueType, memorySpace &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DFT-FE<span id="projectnumber">&#160;1.1.0-pre</span>
   </div>
   <div id="projectbrief">Density Functional Theory With Finite-Elements</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedftfe.html">dftfe</a></li><li class="navelem"><a class="el" href="namespacedftfe_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classdftfe_1_1utils_1_1_memory_storage-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">dftfe::utils::MemoryStorage&lt; ValueType, memorySpace &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_memory_storage_8h_source.html">MemoryStorage.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a97c178a2da2ff077b51f84b5fbf33003" id="r_a97c178a2da2ff077b51f84b5fbf33003"><td class="memItemLeft" align="right" valign="top">typedef ValueType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97c178a2da2ff077b51f84b5fbf33003">value_type</a></td></tr>
<tr class="memdesc:a97c178a2da2ff077b51f84b5fbf33003"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template to provide an interface that can act similar to STL vectors but with different MemorySpace&mdash; HOST (cpu) , DEVICE (gpu), etc,.  <br /></td></tr>
<tr class="separator:a97c178a2da2ff077b51f84b5fbf33003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922fa608ce2a2e4b1e2e91616d3f09f0" id="r_a922fa608ce2a2e4b1e2e91616d3f09f0"><td class="memItemLeft" align="right" valign="top">typedef ValueType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a922fa608ce2a2e4b1e2e91616d3f09f0">pointer</a></td></tr>
<tr class="separator:a922fa608ce2a2e4b1e2e91616d3f09f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f15bec864198b311348b924d8e81eb9" id="r_a2f15bec864198b311348b924d8e81eb9"><td class="memItemLeft" align="right" valign="top">typedef ValueType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f15bec864198b311348b924d8e81eb9">reference</a></td></tr>
<tr class="separator:a2f15bec864198b311348b924d8e81eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee050daa72355825f91816d3b938e3b" id="r_aaee050daa72355825f91816d3b938e3b"><td class="memItemLeft" align="right" valign="top">typedef const ValueType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaee050daa72355825f91816d3b938e3b">const_reference</a></td></tr>
<tr class="separator:aaee050daa72355825f91816d3b938e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24dd6fe5c4072fc009b6714e5ee36006" id="r_a24dd6fe5c4072fc009b6714e5ee36006"><td class="memItemLeft" align="right" valign="top">typedef ValueType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24dd6fe5c4072fc009b6714e5ee36006">iterator</a></td></tr>
<tr class="separator:a24dd6fe5c4072fc009b6714e5ee36006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac513760c004d528c08047207c4e08974" id="r_ac513760c004d528c08047207c4e08974"><td class="memItemLeft" align="right" valign="top">typedef const ValueType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac513760c004d528c08047207c4e08974">const_iterator</a></td></tr>
<tr class="separator:ac513760c004d528c08047207c4e08974"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a816f1f06c424a9ec07b0eab4d265cad5" id="r_a816f1f06c424a9ec07b0eab4d265cad5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a816f1f06c424a9ec07b0eab4d265cad5">MemoryStorage</a> ()=default</td></tr>
<tr class="separator:a816f1f06c424a9ec07b0eab4d265cad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af890cefee7279d03543554a16d313a95" id="r_af890cefee7279d03543554a16d313a95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af890cefee7279d03543554a16d313a95">MemoryStorage</a> (const <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a> &amp;u)</td></tr>
<tr class="memdesc:af890cefee7279d03543554a16d313a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for a MemoryStorage.  <br /></td></tr>
<tr class="separator:af890cefee7279d03543554a16d313a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37d91fae881c7aaffae5661c90a2910" id="r_ac37d91fae881c7aaffae5661c90a2910"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac37d91fae881c7aaffae5661c90a2910">MemoryStorage</a> (<a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a> &amp;&amp;u) noexcept</td></tr>
<tr class="memdesc:ac37d91fae881c7aaffae5661c90a2910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor for a Vector.  <br /></td></tr>
<tr class="separator:ac37d91fae881c7aaffae5661c90a2910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6889f89771c30ae23fe588ff35c63bb3" id="r_a6889f89771c30ae23fe588ff35c63bb3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6889f89771c30ae23fe588ff35c63bb3">MemoryStorage</a> (std::size_t <a class="el" href="#a8eb4504f8bee0b28881f0d65604f9f7e">size</a>, ValueType initVal=0)</td></tr>
<tr class="memdesc:a6889f89771c30ae23fe588ff35c63bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for Vector with size and initial value arguments.  <br /></td></tr>
<tr class="separator:a6889f89771c30ae23fe588ff35c63bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a81d138956b331642b19958251138e2" id="r_a5a81d138956b331642b19958251138e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a81d138956b331642b19958251138e2">~MemoryStorage</a> ()</td></tr>
<tr class="memdesc:a5a81d138956b331642b19958251138e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a5a81d138956b331642b19958251138e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998f773c54881aa83edf83a21bf7d4a5" id="r_a998f773c54881aa83edf83a21bf7d4a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a998f773c54881aa83edf83a21bf7d4a5">clear</a> ()</td></tr>
<tr class="memdesc:a998f773c54881aa83edf83a21bf7d4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear and set to d_data to nullptr  <br /></td></tr>
<tr class="separator:a998f773c54881aa83edf83a21bf7d4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04a60dba8d4cda976bcad4c1af8c4d5" id="r_ac04a60dba8d4cda976bcad4c1af8c4d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac04a60dba8d4cda976bcad4c1af8c4d5">setValue</a> (const ValueType val)</td></tr>
<tr class="memdesc:ac04a60dba8d4cda976bcad4c1af8c4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the entries to a given value.  <br /></td></tr>
<tr class="separator:ac04a60dba8d4cda976bcad4c1af8c4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae2e55c0e10f389bc65f700c6611719" id="r_aeae2e55c0e10f389bc65f700c6611719"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a24dd6fe5c4072fc009b6714e5ee36006">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeae2e55c0e10f389bc65f700c6611719">begin</a> ()</td></tr>
<tr class="memdesc:aeae2e55c0e10f389bc65f700c6611719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator pointing to the beginning of point data.  <br /></td></tr>
<tr class="separator:aeae2e55c0e10f389bc65f700c6611719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce210642221751dccbecd13fe305b4d" id="r_a4ce210642221751dccbecd13fe305b4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac513760c004d528c08047207c4e08974">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ce210642221751dccbecd13fe305b4d">begin</a> () const</td></tr>
<tr class="memdesc:a4ce210642221751dccbecd13fe305b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator pointing to the beginning of Vector data.  <br /></td></tr>
<tr class="separator:a4ce210642221751dccbecd13fe305b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfcdefa08c9fe96f230a1bd97b9e881" id="r_a6cfcdefa08c9fe96f230a1bd97b9e881"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a24dd6fe5c4072fc009b6714e5ee36006">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cfcdefa08c9fe96f230a1bd97b9e881">end</a> ()</td></tr>
<tr class="memdesc:a6cfcdefa08c9fe96f230a1bd97b9e881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator pointing to the end of Vector data.  <br /></td></tr>
<tr class="separator:a6cfcdefa08c9fe96f230a1bd97b9e881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018363f19becdf162dc02901cfda21a8" id="r_a018363f19becdf162dc02901cfda21a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac513760c004d528c08047207c4e08974">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a018363f19becdf162dc02901cfda21a8">end</a> () const</td></tr>
<tr class="memdesc:a018363f19becdf162dc02901cfda21a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator pointing to the end of Vector data.  <br /></td></tr>
<tr class="separator:a018363f19becdf162dc02901cfda21a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e3dd36624251164ff929fe6e67a71b" id="r_ac4e3dd36624251164ff929fe6e67a71b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4e3dd36624251164ff929fe6e67a71b">operator=</a> (const <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a> &amp;rhs)</td></tr>
<tr class="memdesc:ac4e3dd36624251164ff929fe6e67a71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <br /></td></tr>
<tr class="separator:ac4e3dd36624251164ff929fe6e67a71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c57b7d1e9e4c9f95c3dbdd73fff9f0a" id="r_a0c57b7d1e9e4c9f95c3dbdd73fff9f0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c57b7d1e9e4c9f95c3dbdd73fff9f0a">operator=</a> (<a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:a0c57b7d1e9e4c9f95c3dbdd73fff9f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment constructor.  <br /></td></tr>
<tr class="separator:a0c57b7d1e9e4c9f95c3dbdd73fff9f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea95dd493fb885a5e5cc04d4dcb6a9a" id="r_abea95dd493fb885a5e5cc04d4dcb6a9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2f15bec864198b311348b924d8e81eb9">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abea95dd493fb885a5e5cc04d4dcb6a9a">operator[]</a> (std::size_t i)</td></tr>
<tr class="memdesc:abea95dd493fb885a5e5cc04d4dcb6a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator to get a reference to a element of the Vector.  <br /></td></tr>
<tr class="separator:abea95dd493fb885a5e5cc04d4dcb6a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67dd18067d1916d6cbb2f43e188854e8" id="r_a67dd18067d1916d6cbb2f43e188854e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aaee050daa72355825f91816d3b938e3b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67dd18067d1916d6cbb2f43e188854e8">operator[]</a> (std::size_t i) const</td></tr>
<tr class="memdesc:a67dd18067d1916d6cbb2f43e188854e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator to get a const reference to a element of the Vector.  <br /></td></tr>
<tr class="separator:a67dd18067d1916d6cbb2f43e188854e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673649b25448f73587021f756761aea0" id="r_a673649b25448f73587021f756761aea0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a673649b25448f73587021f756761aea0">swap</a> (<a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a> &amp;rhs)</td></tr>
<tr class="separator:a673649b25448f73587021f756761aea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444af8c7c6a92f83b0db6422075ac9b8" id="r_a444af8c7c6a92f83b0db6422075ac9b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a444af8c7c6a92f83b0db6422075ac9b8">resize</a> (std::size_t <a class="el" href="#a8eb4504f8bee0b28881f0d65604f9f7e">size</a>, ValueType initVal=ValueType())</td></tr>
<tr class="memdesc:a444af8c7c6a92f83b0db6422075ac9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates and then resizes Vector with new size and initial value arguments.  <br /></td></tr>
<tr class="separator:a444af8c7c6a92f83b0db6422075ac9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb4504f8bee0b28881f0d65604f9f7e" id="r_a8eb4504f8bee0b28881f0d65604f9f7e"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8eb4504f8bee0b28881f0d65604f9f7e">size</a> () const</td></tr>
<tr class="memdesc:a8eb4504f8bee0b28881f0d65604f9f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the Vector.  <br /></td></tr>
<tr class="separator:a8eb4504f8bee0b28881f0d65604f9f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3f583e6cc54e0deaf65d8ef6a23c59" id="r_aac3f583e6cc54e0deaf65d8ef6a23c59"><td class="memItemLeft" align="right" valign="top">ValueType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac3f583e6cc54e0deaf65d8ef6a23c59">data</a> () noexcept</td></tr>
<tr class="memdesc:aac3f583e6cc54e0deaf65d8ef6a23c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the raw pointer to the Vector.  <br /></td></tr>
<tr class="separator:aac3f583e6cc54e0deaf65d8ef6a23c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2837b289ac474e333828e48c9aa2d4" id="r_aae2837b289ac474e333828e48c9aa2d4"><td class="memItemLeft" align="right" valign="top">const ValueType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae2837b289ac474e333828e48c9aa2d4">data</a> () const noexcept</td></tr>
<tr class="memdesc:aae2837b289ac474e333828e48c9aa2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the raw pointer to the Vector without modifying the values.  <br /></td></tr>
<tr class="separator:aae2837b289ac474e333828e48c9aa2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58b42050a422a237bd2c93ff22414bb" id="r_ae58b42050a422a237bd2c93ff22414bb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpaceDst&gt; </td></tr>
<tr class="memitem:ae58b42050a422a237bd2c93ff22414bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae58b42050a422a237bd2c93ff22414bb">copyTo</a> (<a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a>&lt; ValueType, memorySpaceDst &gt; &amp;dstMemoryStorage) const</td></tr>
<tr class="memdesc:ae58b42050a422a237bd2c93ff22414bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data to a MemoryStorage object in a different memory space. This provides a seamless interface to copy back and forth between memory spaces , including between the same memory spaces.  <br /></td></tr>
<tr class="separator:ae58b42050a422a237bd2c93ff22414bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64d52585f5234363ed700f06ff03e8f" id="r_ad64d52585f5234363ed700f06ff03e8f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpaceDst&gt; </td></tr>
<tr class="memitem:ad64d52585f5234363ed700f06ff03e8f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad64d52585f5234363ed700f06ff03e8f">copyTo</a> (<a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a>&lt; ValueType, memorySpaceDst &gt; &amp;dstMemoryStorage, const std::size_t N, const std::size_t srcOffset, const std::size_t dstOffset) const</td></tr>
<tr class="memdesc:ad64d52585f5234363ed700f06ff03e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data to a MemoryStorage object in a different memory space. This provides a seamless interface to copy back and forth between memory spaces , including between the same memory spaces. This is a more granular version of the above copyTo function as it provides transfer from a specific portion of the source MemoryStorage to a specific portion of the destination MemoryStorage.  <br /></td></tr>
<tr class="separator:ad64d52585f5234363ed700f06ff03e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ade9288f870cce7544f80003760b26" id="r_af9ade9288f870cce7544f80003760b26"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpaceSrc&gt; </td></tr>
<tr class="memitem:af9ade9288f870cce7544f80003760b26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af9ade9288f870cce7544f80003760b26">copyFrom</a> (const <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a>&lt; ValueType, memorySpaceSrc &gt; &amp;srcMemoryStorage)</td></tr>
<tr class="memdesc:af9ade9288f870cce7544f80003760b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a MemoryStorage object in a different memory space. This provides a seamless interface to copy back and forth between memory spaces, including between the same memory spaces.  <br /></td></tr>
<tr class="separator:af9ade9288f870cce7544f80003760b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75314324b8f615f44076c05d14548e4" id="r_aa75314324b8f615f44076c05d14548e4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpaceSrc&gt; </td></tr>
<tr class="memitem:aa75314324b8f615f44076c05d14548e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa75314324b8f615f44076c05d14548e4">copyFrom</a> (const <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a>&lt; ValueType, memorySpaceSrc &gt; &amp;srcMemoryStorage, const std::size_t N, const std::size_t srcOffset, const std::size_t dstOffset)</td></tr>
<tr class="memdesc:aa75314324b8f615f44076c05d14548e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a MemoryStorage object in a different memory space. This provides a seamless interface to copy back and forth between memory spaces, including between the same memory spaces. This is a more granular version of the above copyFrom function as it provides transfer from a specific portion of the source MemoryStorage to a specific portion of the destination MemoryStorage.  <br /></td></tr>
<tr class="separator:aa75314324b8f615f44076c05d14548e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae809a6c181b268ab01db861062cfc7df" id="r_ae809a6c181b268ab01db861062cfc7df"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpaceDst&gt; </td></tr>
<tr class="memitem:ae809a6c181b268ab01db861062cfc7df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae809a6c181b268ab01db861062cfc7df">copyTo</a> (ValueType *dst) const</td></tr>
<tr class="memdesc:ae809a6c181b268ab01db861062cfc7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data to a memory pointed by a raw pointer This provides a seamless interface to copy back and forth between memory spaces, including between the same memory spaces.  <br /></td></tr>
<tr class="separator:ae809a6c181b268ab01db861062cfc7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8379532d334499cbd863fa0021fd2b" id="r_a3f8379532d334499cbd863fa0021fd2b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpaceDst&gt; </td></tr>
<tr class="memitem:a3f8379532d334499cbd863fa0021fd2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3f8379532d334499cbd863fa0021fd2b">copyTo</a> (ValueType *dst, const std::size_t N, const std::size_t srcOffset, const std::size_t dstOffset) const</td></tr>
<tr class="memdesc:a3f8379532d334499cbd863fa0021fd2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data to a memory pointer by a raw pointer. This provides a seamless interface to copy back and forth between memory spaces , including between the same memory spaces. This is a more granular version of the above copyTo function as it provides transfer from a specific portion of the source MemoryStorage to a specific portion of the destination pointer.  <br /></td></tr>
<tr class="separator:a3f8379532d334499cbd863fa0021fd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9657794073bad0c6084e8c07c14bda52" id="r_a9657794073bad0c6084e8c07c14bda52"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpaceSrc&gt; </td></tr>
<tr class="memitem:a9657794073bad0c6084e8c07c14bda52"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9657794073bad0c6084e8c07c14bda52">copyFrom</a> (const ValueType *src)</td></tr>
<tr class="memdesc:a9657794073bad0c6084e8c07c14bda52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a memory pointed by a raw pointer into the MemoryStorage object. This provides a seamless interface to copy back and forth between memory spaces, including between the same memory spaces.  <br /></td></tr>
<tr class="separator:a9657794073bad0c6084e8c07c14bda52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8686cf2bd24fbeffbaf9c98a842dddea" id="r_a8686cf2bd24fbeffbaf9c98a842dddea"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpaceSrc&gt; </td></tr>
<tr class="memitem:a8686cf2bd24fbeffbaf9c98a842dddea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8686cf2bd24fbeffbaf9c98a842dddea">copyFrom</a> (const ValueType *src, const std::size_t N, const std::size_t srcOffset, const std::size_t dstOffset)</td></tr>
<tr class="memdesc:a8686cf2bd24fbeffbaf9c98a842dddea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a memory pointer by a raw pointer into the MemoryStorage object. This provides a seamless interface to copy back and forth between memory spaces, including between the same memory spaces. This is a more granular version of the above copyFrom function as it provides transfer from a specific portion of the source memory to a specific portion of the destination MemoryStorage.  <br /></td></tr>
<tr class="separator:a8686cf2bd24fbeffbaf9c98a842dddea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520ba319687f1105bf4a6f5ae1ffc759" id="r_a520ba319687f1105bf4a6f5ae1ffc759"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a520ba319687f1105bf4a6f5ae1ffc759">copyTo</a> (std::vector&lt; ValueType &gt; &amp;dst) const</td></tr>
<tr class="memdesc:a520ba319687f1105bf4a6f5ae1ffc759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data to a C++ STL vector, which always resides in the CPU. This provides a seamless interface to copy from any memory space to a C++ STL vector, including the case where source memory space is HOST (i.e., it resides on the CPU)  <br /></td></tr>
<tr class="separator:a520ba319687f1105bf4a6f5ae1ffc759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3b0a0320dc03097b77a2182259eda3" id="r_afc3b0a0320dc03097b77a2182259eda3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc3b0a0320dc03097b77a2182259eda3">copyTo</a> (std::vector&lt; ValueType &gt; &amp;dst, const std::size_t N, const std::size_t srcOffset, const std::size_t dstOffset) const</td></tr>
<tr class="memdesc:afc3b0a0320dc03097b77a2182259eda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data to a C++ STL vector, which always resides in the CPU. This provides a seamless interface to copy from any memory space to a C++ STL vector, including the case where source memory space is HOST (i.e., it resides on the CPU). This is a more granular version of the above copyToSTL function as it provides transfer from a specific portion of the MemoryStorage to a specific portion of the destination STL vector.  <br /></td></tr>
<tr class="separator:afc3b0a0320dc03097b77a2182259eda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4943b20cfcde137c1258950ded0b6ce" id="r_aa4943b20cfcde137c1258950ded0b6ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4943b20cfcde137c1258950ded0b6ce">copyFrom</a> (const std::vector&lt; ValueType &gt; &amp;src)</td></tr>
<tr class="memdesc:aa4943b20cfcde137c1258950ded0b6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a C++ STL vector to the MemoryStorage object, which always resides on a CPU. This provides a seamless interface to copy from any memory space, including the case where the same memory spaces is HOST(i.e., the MemoryStorage is on CPU).  <br /></td></tr>
<tr class="separator:aa4943b20cfcde137c1258950ded0b6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994cab8adfaf2185ea6cc428d7d76011" id="r_a994cab8adfaf2185ea6cc428d7d76011"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a994cab8adfaf2185ea6cc428d7d76011">copyFrom</a> (const std::vector&lt; ValueType &gt; &amp;src, const std::size_t N, const std::size_t srcOffset, const std::size_t dstOffset)</td></tr>
<tr class="memdesc:a994cab8adfaf2185ea6cc428d7d76011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a C++ STL vector to the MemoryStorage object, which always resides on a CPU. This provides a seamless interface to copy from any memory space, including the case where the same memory spaces is HOST(i.e., the MemoryStorage is on CPU). This is a more granular version of the above copyFromSTL function as it provides transfer from a specific portion of the source STL vector to to a specific portion of the destination MemoryStorage.  <br /></td></tr>
<tr class="separator:a994cab8adfaf2185ea6cc428d7d76011"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a9099d9430af7f5dfb9c3ffbdead39adb" id="r_a9099d9430af7f5dfb9c3ffbdead39adb"><td class="memItemLeft" align="right" valign="top">ValueType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9099d9430af7f5dfb9c3ffbdead39adb">d_data</a> = nullptr</td></tr>
<tr class="separator:a9099d9430af7f5dfb9c3ffbdead39adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dcd948533b248845d62b3e28fab890" id="r_a56dcd948533b248845d62b3e28fab890"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56dcd948533b248845d62b3e28fab890">d_size</a> = 0</td></tr>
<tr class="separator:a56dcd948533b248845d62b3e28fab890"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac513760c004d528c08047207c4e08974" name="ac513760c004d528c08047207c4e08974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac513760c004d528c08047207c4e08974">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const ValueType* <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaee050daa72355825f91816d3b938e3b" name="aaee050daa72355825f91816d3b938e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee050daa72355825f91816d3b938e3b">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const ValueType&amp; <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::const_reference</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24dd6fe5c4072fc009b6714e5ee36006" name="a24dd6fe5c4072fc009b6714e5ee36006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24dd6fe5c4072fc009b6714e5ee36006">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ValueType* <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a922fa608ce2a2e4b1e2e91616d3f09f0" name="a922fa608ce2a2e4b1e2e91616d3f09f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922fa608ce2a2e4b1e2e91616d3f09f0">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ValueType* <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f15bec864198b311348b924d8e81eb9" name="a2f15bec864198b311348b924d8e81eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f15bec864198b311348b924d8e81eb9">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ValueType&amp; <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::reference</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97c178a2da2ff077b51f84b5fbf33003" name="a97c178a2da2ff077b51f84b5fbf33003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c178a2da2ff077b51f84b5fbf33003">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ValueType <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A class template to provide an interface that can act similar to STL vectors but with different MemorySpace&mdash; HOST (cpu) , DEVICE (gpu), etc,. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The underlying value type for the MemoryStorage (e.g., int, double, complex&lt;double&gt;, etc.) </td></tr>
    <tr><td class="paramname">memorySpace</td><td>The memory space in which the MemoryStorage needs to reside </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a816f1f06c424a9ec07b0eab4d265cad5" name="a816f1f06c424a9ec07b0eab4d265cad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816f1f06c424a9ec07b0eab4d265cad5">&#9670;&#160;</a></span>MemoryStorage() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::MemoryStorage </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af890cefee7279d03543554a16d313a95" name="af890cefee7279d03543554a16d313a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af890cefee7279d03543554a16d313a95">&#9670;&#160;</a></span>MemoryStorage() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::MemoryStorage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a>&lt; ValueType, memorySpace &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor for a MemoryStorage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>MemoryStorage object to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac37d91fae881c7aaffae5661c90a2910" name="ac37d91fae881c7aaffae5661c90a2910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37d91fae881c7aaffae5661c90a2910">&#9670;&#160;</a></span>MemoryStorage() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::MemoryStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a>&lt; ValueType, memorySpace &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor for a Vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>Vector object to move from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6889f89771c30ae23fe588ff35c63bb3" name="a6889f89771c30ae23fe588ff35c63bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6889f89771c30ae23fe588ff35c63bb3">&#9670;&#160;</a></span>MemoryStorage() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::MemoryStorage </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType</td>          <td class="paramname"><span class="paramname"><em>initVal</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for Vector with size and initial value arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of the Vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initVal</td><td>initial value of elements of the Vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a81d138956b331642b19958251138e2" name="a5a81d138956b331642b19958251138e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a81d138956b331642b19958251138e2">&#9670;&#160;</a></span>~MemoryStorage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::~<a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeae2e55c0e10f389bc65f700c6611719" name="aeae2e55c0e10f389bc65f700c6611719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae2e55c0e10f389bc65f700c6611719">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a24dd6fe5c4072fc009b6714e5ee36006">iterator</a> <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return iterator pointing to the beginning of point data. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the beginning of Vector. </dd></dl>

</div>
</div>
<a id="a4ce210642221751dccbecd13fe305b4d" name="a4ce210642221751dccbecd13fe305b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce210642221751dccbecd13fe305b4d">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac513760c004d528c08047207c4e08974">const_iterator</a> <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return iterator pointing to the beginning of Vector data. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator pointing to the beginning of Vector. </dd></dl>

</div>
</div>
<a id="a998f773c54881aa83edf83a21bf7d4a5" name="a998f773c54881aa83edf83a21bf7d4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998f773c54881aa83edf83a21bf7d4a5">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clear and set to d_data to nullptr </p>

</div>
</div>
<a id="af9ade9288f870cce7544f80003760b26" name="af9ade9288f870cce7544f80003760b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ade9288f870cce7544f80003760b26">&#9670;&#160;</a></span>copyFrom() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpaceSrc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a>&lt; ValueType, memorySpaceSrc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>srcMemoryStorage</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from a MemoryStorage object in a different memory space. This provides a seamless interface to copy back and forth between memory spaces, including between the same memory spaces. </p>
<dl class="section note"><dt>Note</dt><dd>The MemoryStorage must be pre-allocated appropriately</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">memorySpaceSrc</td><td>memory space of the source MemoryStorage from which to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcMemoryStorage</td><td>reference to the source MemoryStorage </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">utils::LengthError</td><td>exception if the size of underlying MemoryStorage is less than size of srcMemoryStorage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa75314324b8f615f44076c05d14548e4" name="aa75314324b8f615f44076c05d14548e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75314324b8f615f44076c05d14548e4">&#9670;&#160;</a></span>copyFrom() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpaceSrc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a>&lt; ValueType, memorySpaceSrc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>srcMemoryStorage</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>N</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>srcOffset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>dstOffset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from a MemoryStorage object in a different memory space. This provides a seamless interface to copy back and forth between memory spaces, including between the same memory spaces. This is a more granular version of the above copyFrom function as it provides transfer from a specific portion of the source MemoryStorage to a specific portion of the destination MemoryStorage. </p>
<dl class="section note"><dt>Note</dt><dd>The MemoryStorage must be pre-allocated appropriately</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">memorySpaceSrc</td><td>memory space of the source MemoryStorage from which to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcMemoryStorage</td><td>reference to the source MemoryStorage </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>number of entries of the source MemoryStorage that needs to be copied to the destination MemoryStorage </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcOffset</td><td>offset relative to the start of the source MemoryStorage from which we need to copy data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstOffset</td><td>offset relative to the start of the destination MemoryStorage to which we need to copy data </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">utils::LengthError</td><td>exception if the size of srcMemoryStorage is less than N + srcOffset </td></tr>
    <tr><td class="paramname">utils::LengthError</td><td>exception if the size of underlying MemoryStorage is less than N + dstOffset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4943b20cfcde137c1258950ded0b6ce" name="aa4943b20cfcde137c1258950ded0b6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4943b20cfcde137c1258950ded0b6ce">&#9670;&#160;</a></span>copyFrom() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; ValueType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from a C++ STL vector to the MemoryStorage object, which always resides on a CPU. This provides a seamless interface to copy from any memory space, including the case where the same memory spaces is HOST(i.e., the MemoryStorage is on CPU). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>const reference to the source C++ STL vector from which the data needs to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">utils::LengthError</td><td>exception if the size of the MemoryStorage is less than the size of the src </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a994cab8adfaf2185ea6cc428d7d76011" name="a994cab8adfaf2185ea6cc428d7d76011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994cab8adfaf2185ea6cc428d7d76011">&#9670;&#160;</a></span>copyFrom() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; ValueType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>N</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>srcOffset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>dstOffset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from a C++ STL vector to the MemoryStorage object, which always resides on a CPU. This provides a seamless interface to copy from any memory space, including the case where the same memory spaces is HOST(i.e., the MemoryStorage is on CPU). This is a more granular version of the above copyFromSTL function as it provides transfer from a specific portion of the source STL vector to to a specific portion of the destination MemoryStorage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>const reference to the source C++ STL vector from which the data needs to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>number of entries of the source pointer that needs to be copied to the destination MemoryStorage </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcOffset</td><td>offset relative to the start of the source STL vector from which we need to copy data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstOffset</td><td>offset relative to the start of the destination MemoryStorage to which we need to copy data </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">utils::LengthError</td><td>exception if the size of src is less than N + srcOffset </td></tr>
    <tr><td class="paramname">utils::LengthError</td><td>exception if the size of the MemoryStorage is less thant N + dstOffset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9657794073bad0c6084e8c07c14bda52" name="a9657794073bad0c6084e8c07c14bda52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9657794073bad0c6084e8c07c14bda52">&#9670;&#160;</a></span>copyFrom() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpaceSrc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const ValueType *</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from a memory pointed by a raw pointer into the MemoryStorage object. This provides a seamless interface to copy back and forth between memory spaces, including between the same memory spaces. </p>
<dl class="section note"><dt>Note</dt><dd>The src pointer must point to a memory chunk that is at least the size of the MemoryStorage</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">memorySpaceSrc</td><td>memory space of the source pointer from which to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the source memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8686cf2bd24fbeffbaf9c98a842dddea" name="a8686cf2bd24fbeffbaf9c98a842dddea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8686cf2bd24fbeffbaf9c98a842dddea">&#9670;&#160;</a></span>copyFrom() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpaceSrc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const ValueType *</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>N</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>srcOffset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>dstOffset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from a memory pointer by a raw pointer into the MemoryStorage object. This provides a seamless interface to copy back and forth between memory spaces, including between the same memory spaces. This is a more granular version of the above copyFrom function as it provides transfer from a specific portion of the source memory to a specific portion of the destination MemoryStorage. </p>
<dl class="section note"><dt>Note</dt><dd>The src pointer must point to a memory chunk that is at least the size of N + srcOffset</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">memorySpaceSrc</td><td>memory space of the source pointer from which to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the source memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>number of entries of the source pointer that needs to be copied to the destination MemoryStorage </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcOffset</td><td>offset relative to the start of the source pointer from which we need to copy data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstOffset</td><td>offset relative to the start of the destination MemoryStorage to which we need to copy data </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">utils::LengthError</td><td>exception if the size of the MemoryStorage is less than N + dstOffset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae58b42050a422a237bd2c93ff22414bb" name="ae58b42050a422a237bd2c93ff22414bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58b42050a422a237bd2c93ff22414bb">&#9670;&#160;</a></span>copyTo() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpaceDst&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a>&lt; ValueType, memorySpaceDst &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dstMemoryStorage</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the data to a MemoryStorage object in a different memory space. This provides a seamless interface to copy back and forth between memory spaces , including between the same memory spaces. </p>
<dl class="section note"><dt>Note</dt><dd>The destination MemoryStorage must be pre-allocated appropriately</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">memorySpaceDst</td><td>memory space of the destination MemoryStorage </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dstMemoryStorage</td><td>reference to the destination MemoryStorage. It must be pre-allocated appropriately </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dstMemoryStorage</td><td>reference to the destination MemoryStorage with the data copied into it </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">utils::LengthError</td><td>exception if the size of dstMemoryStorage is less than underlying MemoryStorage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad64d52585f5234363ed700f06ff03e8f" name="ad64d52585f5234363ed700f06ff03e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64d52585f5234363ed700f06ff03e8f">&#9670;&#160;</a></span>copyTo() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpaceDst&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a>&lt; ValueType, memorySpaceDst &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dstMemoryStorage</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>N</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>srcOffset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>dstOffset</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the data to a MemoryStorage object in a different memory space. This provides a seamless interface to copy back and forth between memory spaces , including between the same memory spaces. This is a more granular version of the above copyTo function as it provides transfer from a specific portion of the source MemoryStorage to a specific portion of the destination MemoryStorage. </p>
<dl class="section note"><dt>Note</dt><dd>The destination MemoryStorage must be pre-allocated appropriately</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">memorySpaceDst</td><td>memory space of the destination MemoryStorage </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dstMemoryStorage</td><td>reference to the destination MemoryStorage. It must be pre-allocated appropriately </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>number of entries of the source MemoryStorage that needs to be copied to the destination MemoryStorage </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcOffset</td><td>offset relative to the start of the source MemoryStorage from which we need to copy data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstOffset</td><td>offset relative to the start of the destination MemoryStorage to which we need to copy data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dstMemoryStorage</td><td>reference to the destination MemoryStorage with the data copied into it </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">utils::LengthError</td><td>exception if the size of dstMemoryStorage is less than N + dstOffset </td></tr>
    <tr><td class="paramname">utils::LengthError</td><td>exception if the size of underlying MemoryStorage is less than N + srcOffset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a520ba319687f1105bf4a6f5ae1ffc759" name="a520ba319687f1105bf4a6f5ae1ffc759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520ba319687f1105bf4a6f5ae1ffc759">&#9670;&#160;</a></span>copyTo() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::copyTo </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; ValueType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the data to a C++ STL vector, which always resides in the CPU. This provides a seamless interface to copy from any memory space to a C++ STL vector, including the case where source memory space is HOST (i.e., it resides on the CPU) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>reference to the destination C++ STL vector to which the data needs to be copied. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>reference to the destination C++ STL vector with the data copied into it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the size of the dst vector is less than the the size of the underlying MemoryStorage, it will be resized. Thus, for performance reasons, it is recommened that the dst STL vector be pre-allocated appropriately. </dd></dl>

</div>
</div>
<a id="afc3b0a0320dc03097b77a2182259eda3" name="afc3b0a0320dc03097b77a2182259eda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3b0a0320dc03097b77a2182259eda3">&#9670;&#160;</a></span>copyTo() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::copyTo </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; ValueType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>N</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>srcOffset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>dstOffset</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the data to a C++ STL vector, which always resides in the CPU. This provides a seamless interface to copy from any memory space to a C++ STL vector, including the case where source memory space is HOST (i.e., it resides on the CPU). This is a more granular version of the above copyToSTL function as it provides transfer from a specific portion of the MemoryStorage to a specific portion of the destination STL vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>reference to the destination C++ STL vector to which the data needs to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the size of the dst vector is less than the the size of the underlying memory storage, it will be resized. Thus, for performance reasons it is recommened to should be allocated appropriately. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>number of entries of the source MemoryStorage that needs to be copied to the destination pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcOffset</td><td>offset relative to the start of the source MemoryStorage from which we need to copy data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstOffset</td><td>offset relative to the start of the STL vector to which we need to copy data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>reference to the destination C++ STL vector with the data copied into it </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">utils::LengthError</td><td>exception if the size of the MemoryStorage is less than N + srcOffset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the size of the dst vector is less N + srcOffset, it will be resized. Thus, for performance reasons, it is recommened that the dst STL vector be allocated appropriately. </dd></dl>

</div>
</div>
<a id="ae809a6c181b268ab01db861062cfc7df" name="ae809a6c181b268ab01db861062cfc7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae809a6c181b268ab01db861062cfc7df">&#9670;&#160;</a></span>copyTo() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpaceDst&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::copyTo </td>
          <td>(</td>
          <td class="paramtype">ValueType *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the data to a memory pointed by a raw pointer This provides a seamless interface to copy back and forth between memory spaces, including between the same memory spaces. </p>
<dl class="section note"><dt>Note</dt><dd>The destination pointer must be pre-allocated to be at least of the size of the MemoryStorage</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">memorySpaceDst</td><td>memory space of the destination pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>pointer to the destination. It must be pre-allocated appropriately </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>pointer to the destination with the data copied into it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f8379532d334499cbd863fa0021fd2b" name="a3f8379532d334499cbd863fa0021fd2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8379532d334499cbd863fa0021fd2b">&#9670;&#160;</a></span>copyTo() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpaceDst&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::copyTo </td>
          <td>(</td>
          <td class="paramtype">ValueType *</td>          <td class="paramname"><span class="paramname"><em>dst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>N</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>srcOffset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>dstOffset</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the data to a memory pointer by a raw pointer. This provides a seamless interface to copy back and forth between memory spaces , including between the same memory spaces. This is a more granular version of the above copyTo function as it provides transfer from a specific portion of the source MemoryStorage to a specific portion of the destination pointer. </p>
<dl class="section note"><dt>Note</dt><dd>The destination pointer must be pre-allocated to be at least of the size N + dstOffset</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">memorySpaceDst</td><td>memory space of the destination pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>pointer to the destination. It must be pre-allocated appropriately </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>number of entries of the source MemoryStorage that needs to be copied to the destination pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcOffset</td><td>offset relative to the start of the source MemoryStorage from which we need to copy data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstOffset</td><td>offset relative to the start of the destination pointer to which we need to copy data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>pointer to the destination with the data copied into it </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">utils::LengthError</td><td>exception if the size of the MemoryStorage is less than N + srcOffset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae2837b289ac474e333828e48c9aa2d4" name="aae2837b289ac474e333828e48c9aa2d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2837b289ac474e333828e48c9aa2d4">&#9670;&#160;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ValueType * <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the raw pointer to the Vector without modifying the values. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to const data </dd></dl>

</div>
</div>
<a id="aac3f583e6cc54e0deaf65d8ef6a23c59" name="aac3f583e6cc54e0deaf65d8ef6a23c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3f583e6cc54e0deaf65d8ef6a23c59">&#9670;&#160;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType * <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the raw pointer to the Vector. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to data </dd></dl>

</div>
</div>
<a id="a6cfcdefa08c9fe96f230a1bd97b9e881" name="a6cfcdefa08c9fe96f230a1bd97b9e881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfcdefa08c9fe96f230a1bd97b9e881">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a24dd6fe5c4072fc009b6714e5ee36006">iterator</a> <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return iterator pointing to the end of Vector data. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the end of Vector. </dd></dl>

</div>
</div>
<a id="a018363f19becdf162dc02901cfda21a8" name="a018363f19becdf162dc02901cfda21a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018363f19becdf162dc02901cfda21a8">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac513760c004d528c08047207c4e08974">const_iterator</a> <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return iterator pointing to the end of Vector data. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator pointing to the end of Vector. </dd></dl>

</div>
</div>
<a id="ac4e3dd36624251164ff929fe6e67a71b" name="ac4e3dd36624251164ff929fe6e67a71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e3dd36624251164ff929fe6e67a71b">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a> &amp; <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a>&lt; ValueType, memorySpace &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the rhs Vector from which to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the lhs Vector </dd></dl>

</div>
</div>
<a id="a0c57b7d1e9e4c9f95c3dbdd73fff9f0a" name="a0c57b7d1e9e4c9f95c3dbdd73fff9f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c57b7d1e9e4c9f95c3dbdd73fff9f0a">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a> &amp; <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a>&lt; ValueType, memorySpace &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the rhs Vector from which to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the lhs Vector </dd></dl>

</div>
</div>
<a id="abea95dd493fb885a5e5cc04d4dcb6a9a" name="abea95dd493fb885a5e5cc04d4dcb6a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea95dd493fb885a5e5cc04d4dcb6a9a">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2f15bec864198b311348b924d8e81eb9">reference</a> <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator to get a reference to a element of the Vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>is the index to the element of the Vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the element of the Vector </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if i &gt;= size of the Vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67dd18067d1916d6cbb2f43e188854e8" name="a67dd18067d1916d6cbb2f43e188854e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67dd18067d1916d6cbb2f43e188854e8">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aaee050daa72355825f91816d3b938e3b">const_reference</a> <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator to get a const reference to a element of the Vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>is the index to the element of the Vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const reference to the element of the Vector </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if i &gt;= size of the Vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a444af8c7c6a92f83b0db6422075ac9b8" name="a444af8c7c6a92f83b0db6422075ac9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444af8c7c6a92f83b0db6422075ac9b8">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType</td>          <td class="paramname"><span class="paramname"><em>initVal</em><span class="paramdefsep"> = </span><span class="paramdefval">ValueType()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates and then resizes Vector with new size and initial value arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of the Vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initVal</td><td>initial value of elements of the Vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac04a60dba8d4cda976bcad4c1af8c4d5" name="ac04a60dba8d4cda976bcad4c1af8c4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04a60dba8d4cda976bcad4c1af8c4d5">&#9670;&#160;</a></span>setValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::setValue </td>
          <td>(</td>
          <td class="paramtype">const ValueType</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all the entries to a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to which the entries are to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8eb4504f8bee0b28881f0d65604f9f7e" name="a8eb4504f8bee0b28881f0d65604f9f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb4504f8bee0b28881f0d65604f9f7e">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the dimension of the Vector. </p>
<dl class="section return"><dt>Returns</dt><dd>size of the Vector </dd></dl>

</div>
</div>
<a id="a673649b25448f73587021f756761aea0" name="a673649b25448f73587021f756761aea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673649b25448f73587021f756761aea0">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">MemoryStorage</a>&lt; ValueType, memorySpace &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9099d9430af7f5dfb9c3ffbdead39adb" name="a9099d9430af7f5dfb9c3ffbdead39adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9099d9430af7f5dfb9c3ffbdead39adb">&#9670;&#160;</a></span>d_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType* <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::d_data = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a56dcd948533b248845d62b3e28fab890" name="a56dcd948533b248845d62b3e28fab890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56dcd948533b248845d62b3e28fab890">&#9670;&#160;</a></span>d_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedftfe_1_1utils.html#a70cf7f171e9701571a428ad0fa1bf341">dftfe::utils::MemorySpace</a> memorySpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classdftfe_1_1utils_1_1_memory_storage.html">dftfe::utils::MemoryStorage</a>&lt; ValueType, memorySpace &gt;::d_size = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>workspace/include/<a class="el" href="_memory_storage_8h_source.html">MemoryStorage.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
